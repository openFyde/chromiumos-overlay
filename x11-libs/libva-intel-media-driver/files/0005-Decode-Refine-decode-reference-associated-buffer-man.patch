From ea3d0eff65b6bea0c52175f2bc0d6bb4a312da2e Mon Sep 17 00:00:00 2001
From: StevenLi <steven.li@intel.com>
Date: Fri, 8 Jan 2021 14:35:37 +0800
Subject: [PATCH] [Decode] Refine decode reference associated buffer management
 to avoid potential shared buffer overwritten

Refine decode reference associated buffer management to avoid potential shared buffer overwritten.
1. Adding reference count for AV1 shared buffer, reuse shared buffer only when reference count is zero.
2. Reusing retired temporal buffer other than empty buffer to improve the robustness with error stream.
3. Correct typo.
---
 .../features/decode_av1_temporal_buffers.cpp  | 102 +++++++++++++-----
 .../features/decode_av1_temporal_buffers.h    |  21 +++-
 .../av1/packet/decode_av1_picture_packet.cpp  |  13 ++-
 .../decode_reference_associated_buffer.h      |  70 +++++++-----
 4 files changed, 148 insertions(+), 58 deletions(-)

diff --git a/media_driver/media_driver_next/agnostic/common/codec/hal/dec/av1/features/decode_av1_temporal_buffers.cpp b/media_driver/media_driver_next/agnostic/common/codec/hal/dec/av1/features/decode_av1_temporal_buffers.cpp
index 591445fb..ff5541cf 100644
--- a/media_driver/media_driver_next/agnostic/common/codec/hal/dec/av1/features/decode_av1_temporal_buffers.cpp
+++ b/media_driver/media_driver_next/agnostic/common/codec/hal/dec/av1/features/decode_av1_temporal_buffers.cpp
@@ -1,5 +1,5 @@
 /*
-* Copyright (c) 2019-2020, Intel Corporation
+* Copyright (c) 2019-2021, Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
@@ -64,9 +64,9 @@ namespace decode
         {
             DECODE_ASSERTMESSAGE( "Failed to get SegmentIdBuffer size.");
         }
-        bufs->segIdWriteBuf = m_allocator->AllocateBuffer(avpBufSizeParam.m_bufferSize, "SegmentIdWriteBuffer", resourceInternalReadWriteCache);
+        bufs->segIdWriteBuf.buffer = m_allocator->AllocateBuffer(avpBufSizeParam.m_bufferSize, "SegmentIdWriteBuffer", resourceInternalReadWriteCache);
 
-        bufs->bwdAdaptCdfBuf = m_allocator->AllocateBuffer(MOS_ALIGN_CEIL(m_basicFeature->m_cdfMaxNumBytes,
+        bufs->bwdAdaptCdfBuf.buffer = m_allocator->AllocateBuffer(MOS_ALIGN_CEIL(m_basicFeature->m_cdfMaxNumBytes,
             CODECHAL_PAGE_SIZE), "CdfTableBuffer", resourceInternalReadWriteCache);
         return bufs;
     }
@@ -93,7 +93,7 @@ namespace decode
         DECODE_CHK_STATUS(m_avpInterface->GetAv1BufferSize(
             segmentIdBuf,
             &avpBufSizeParam));
-        DECODE_CHK_STATUS(m_allocator->Resize(buffer->segIdWriteBuf, avpBufSizeParam.m_bufferSize, false));
+        DECODE_CHK_STATUS(m_allocator->Resize(buffer->segIdWriteBuf.buffer, avpBufSizeParam.m_bufferSize, false));
 
         RecordSegIdBufInfo(buffer);
         RecordCdfTableBufInfo(buffer);
@@ -128,16 +128,17 @@ namespace decode
         {
             if (picParams->m_av1SegData.m_updateMap)
             {
-                buffer->segIdBuf = buffer->segIdWriteBuf;
+                buffer->segIdBuf = RefSharedBuffer(&buffer->segIdWriteBuf);
             }
             else
             {
                 auto tempBuffers = &(m_basicFeature->m_tempBuffers);
-                if (tempBuffers->GetBufferByFrameIndex(prevFrameIdx) != nullptr)
+                auto prevTempBuffer = tempBuffers->GetBufferByFrameIndex(prevFrameIdx);
+                if (prevTempBuffer != nullptr)
                 {
                     if (m_basicFeature->m_refFrames.CheckSegForPrimFrame(*picParams))
                     {
-                        buffer->segIdBuf = tempBuffers->GetBufferByFrameIndex(prevFrameIdx)->segIdBuf;
+                        buffer->segIdBuf = RefSharedBuffer(prevTempBuffer->segIdBuf);
                     }
                     else
                     {
@@ -157,37 +158,58 @@ namespace decode
         auto    picParams              = m_basicFeature->m_av1PicParams;
         uint8_t prevFrameIdx           = m_basicFeature->m_refFrames.GetPrimaryRefIdx();
         buffer->disableFrmEndUpdateCdf = picParams->m_picInfoFlags.m_fields.m_disableFrameEndUpdateCdf;
+
         if (picParams->m_primaryRefFrame == av1PrimaryRefNone)
         {
-            buffer->initCdfBuf = m_basicFeature->m_defaultCdfBufferInUse;
+            buffer->defaultCdfBuf.buffer = m_basicFeature->m_defaultCdfBufferInUse;
+            buffer->initCdfBuf = RefSharedBuffer(&buffer->defaultCdfBuf);
         }
         else
         {
             auto tempBuffers = &(m_basicFeature->m_tempBuffers);
-            if (tempBuffers->GetBufferByFrameIndex(prevFrameIdx) != nullptr)
+            auto prevTempBuffer = tempBuffers->GetBufferByFrameIndex(prevFrameIdx);
+            if (prevTempBuffer != nullptr)
             {
-                if (tempBuffers->GetBufferByFrameIndex(prevFrameIdx)->disableFrmEndUpdateCdf)
+                if (prevTempBuffer->disableFrmEndUpdateCdf)
                 {
-                    buffer->initCdfBuf = tempBuffers->GetBufferByFrameIndex(prevFrameIdx)->initCdfBuf;
+                    buffer->initCdfBuf = RefSharedBuffer(prevTempBuffer->initCdfBuf);
                 }
                 else
                 {
-                    buffer->initCdfBuf = tempBuffers->GetBufferByFrameIndex(prevFrameIdx)->bwdAdaptCdfBuf;
-                }
-
-                //If init cdf buffer and bwdAdapt cdf buffer point to same memory address,
-                //should get a another bwdAdapt cdf buffer for cdf stream out from avaliable buffer pool.
-                if (buffer->initCdfBuf == buffer->bwdAdaptCdfBuf)
-                {
-                    auto        aviabuf     = tempBuffers->GetAviableBuffer();
-                    PMOS_BUFFER temp        = aviabuf->bwdAdaptCdfBuf;
-                    aviabuf->bwdAdaptCdfBuf = buffer->bwdAdaptCdfBuf;
-                    buffer->bwdAdaptCdfBuf  = temp;
+                    buffer->initCdfBuf = RefSharedBuffer(&prevTempBuffer->bwdAdaptCdfBuf);
                 }
             }
         }
     }
 
+    MOS_STATUS Av1TempBufferOpInf::Deactive(Av1RefAssociatedBufs* &buffer)
+    {
+        DeRefSharedBuffer(buffer->segIdBuf);
+        DeRefSharedBuffer(buffer->initCdfBuf);
+        return MOS_STATUS_SUCCESS;
+    }
+
+    bool Av1TempBufferOpInf::IsAvailable(Av1RefAssociatedBufs* &buffer)
+    {
+        if (buffer == nullptr)
+        {
+            return false;
+        }
+        if (buffer->segIdWriteBuf.refCnt > 0)
+        {
+            return false;
+        }
+        if (buffer->bwdAdaptCdfBuf.refCnt > 0)
+        {
+            return false;
+        }
+        if (buffer->defaultCdfBuf.refCnt > 0)
+        {
+            return false;
+        }
+        return true;
+    }
+
     void Av1TempBufferOpInf::Destroy(Av1RefAssociatedBufs* &buffer)
     {
         DECODE_FUNC_CALL();
@@ -195,12 +217,44 @@ namespace decode
         if (buffer != nullptr)
         {
             m_allocator->Destroy(buffer->mvBuf);
-            m_allocator->Destroy(buffer->segIdWriteBuf);
-            m_allocator->Destroy(buffer->bwdAdaptCdfBuf);
+
+            m_allocator->Destroy(buffer->segIdWriteBuf.buffer);
+            if (buffer->segIdWriteBuf.refCnt != 0)
+            {
+                DECODE_NORMALMESSAGE("The reference count is %d while destory SegId buffer", buffer->segIdWriteBuf.refCnt);
+            }
+
+            m_allocator->Destroy(buffer->bwdAdaptCdfBuf.buffer);
+            if (buffer->bwdAdaptCdfBuf.refCnt != 0)
+            {
+                DECODE_NORMALMESSAGE("The reference count is %d while destory CDF buffer", buffer->bwdAdaptCdfBuf.refCnt);
+            }
 
             MOS_Delete(buffer);
             buffer = nullptr;
         }
     }
 
+    Av1SharedBuf *Av1TempBufferOpInf::RefSharedBuffer(Av1SharedBuf *sharedBuf)
+    {
+        if (sharedBuf != nullptr)
+        {
+            sharedBuf->refCnt++;
+        }
+        return sharedBuf;
+    }
+
+    Av1SharedBuf *Av1TempBufferOpInf::DeRefSharedBuffer(Av1SharedBuf *sharedBuf)
+    {
+        if (sharedBuf != nullptr)
+        {
+            sharedBuf->refCnt--;
+            if (sharedBuf->refCnt < 0)
+            {
+                DECODE_ASSERTMESSAGE("AV1 shared buffer reference count is %d which should not small than zero.", sharedBuf->refCnt);
+                sharedBuf->refCnt = 0;
+            }
+        }
+        return sharedBuf;
+    }
 }  // namespace decode
diff --git a/media_driver/media_driver_next/agnostic/common/codec/hal/dec/av1/features/decode_av1_temporal_buffers.h b/media_driver/media_driver_next/agnostic/common/codec/hal/dec/av1/features/decode_av1_temporal_buffers.h
index bcb413ce..157f049a 100644
--- a/media_driver/media_driver_next/agnostic/common/codec/hal/dec/av1/features/decode_av1_temporal_buffers.h
+++ b/media_driver/media_driver_next/agnostic/common/codec/hal/dec/av1/features/decode_av1_temporal_buffers.h
@@ -1,5 +1,5 @@
 /*
-* Copyright (c) 2019-2020, Intel Corporation
+* Copyright (c) 2019-2021, Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
@@ -35,13 +35,20 @@ namespace decode
 {
     class Av1BasicFeature;
 
+    struct Av1SharedBuf
+    {
+        PMOS_BUFFER buffer = nullptr;
+        int refCnt = 0;
+    };
+
     struct Av1RefAssociatedBufs
     {
         PMOS_BUFFER mvBuf = nullptr;
-        PMOS_BUFFER segIdBuf = nullptr;
-        PMOS_BUFFER segIdWriteBuf = nullptr;
-        PMOS_BUFFER initCdfBuf = nullptr;
-        PMOS_BUFFER bwdAdaptCdfBuf = nullptr;
+        Av1SharedBuf *segIdBuf = nullptr;
+        Av1SharedBuf segIdWriteBuf;
+        Av1SharedBuf *initCdfBuf = nullptr;
+        Av1SharedBuf bwdAdaptCdfBuf;
+        Av1SharedBuf defaultCdfBuf;
         bool disableFrmEndUpdateCdf = false;
     };
 
@@ -53,11 +60,15 @@ namespace decode
                         Av1BasicFeature& basicFeature);
         virtual Av1RefAssociatedBufs *Allocate();
         virtual MOS_STATUS Resize(Av1RefAssociatedBufs* &buffer);
+        virtual MOS_STATUS Deactive(Av1RefAssociatedBufs* &buffer);
+        virtual bool IsAvailable(Av1RefAssociatedBufs* &buffer);
         virtual void Destroy(Av1RefAssociatedBufs* &buffer);
     protected:
         void                  SetAvpBufSizeParam(MhwVdboxAvpBufferSizeParams& params, int32_t mibSizeLog2);
         void                  RecordSegIdBufInfo(Av1RefAssociatedBufs *buffer);
         void                  RecordCdfTableBufInfo(Av1RefAssociatedBufs *buffer);
+        inline Av1SharedBuf  *RefSharedBuffer(Av1SharedBuf *sharedBuf);
+        inline Av1SharedBuf  *DeRefSharedBuffer(Av1SharedBuf *sharedBuf);
         MhwVdboxAvpInterface *m_avpInterface = nullptr;  //!< Avp interface;
         int32_t               widthInSb;
         int32_t               heightInSb;
diff --git a/media_driver/media_driver_next/agnostic/common/codec/hal/dec/av1/packet/decode_av1_picture_packet.cpp b/media_driver/media_driver_next/agnostic/common/codec/hal/dec/av1/packet/decode_av1_picture_packet.cpp
index b32e46fd..9d97585d 100644
--- a/media_driver/media_driver_next/agnostic/common/codec/hal/dec/av1/packet/decode_av1_picture_packet.cpp
+++ b/media_driver/media_driver_next/agnostic/common/codec/hal/dec/av1/packet/decode_av1_picture_packet.cpp
@@ -1,5 +1,5 @@
 /*
-* Copyright (c) 2019-2020, Intel Corporation
+* Copyright (c) 2019-2021, Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
@@ -1151,20 +1151,21 @@ namespace decode{
 
         DECODE_CHK_STATUS(FixAvpPipeBufAddrParams(pipeBufAddrParams));
 
-        PMOS_BUFFER curInitCdfBuffer = tempBuffers->GetCurBuffer()->initCdfBuf;
+        DECODE_CHK_NULL(tempBuffers->GetCurBuffer()->initCdfBuf);
+        PMOS_BUFFER curInitCdfBuffer = tempBuffers->GetCurBuffer()->initCdfBuf->buffer;
         DECODE_CHK_NULL(curInitCdfBuffer);
         pipeBufAddrParams.m_cdfTableInitializationBuffer = &(curInitCdfBuffer->OsResource);
 
         if (!m_av1PicParams->m_picInfoFlags.m_fields.m_disableFrameEndUpdateCdf)
         {
-            PMOS_BUFFER curBwdCdfBuffer = tempBuffers->GetCurBuffer()->bwdAdaptCdfBuf;
+            PMOS_BUFFER curBwdCdfBuffer = tempBuffers->GetCurBuffer()->bwdAdaptCdfBuf.buffer;
             DECODE_CHK_NULL(curBwdCdfBuffer);
             pipeBufAddrParams.m_cdfTableBwdAdaptationBuffer = &(curBwdCdfBuffer->OsResource);
         }
 
         if (m_av1PicParams->m_av1SegData.m_enabled && m_av1PicParams->m_av1SegData.m_updateMap)
         {
-            PMOS_BUFFER curSegIDWriteBuffer = tempBuffers->GetCurBuffer()->segIdWriteBuf;
+            PMOS_BUFFER curSegIDWriteBuffer = tempBuffers->GetCurBuffer()->segIdWriteBuf.buffer;
             DECODE_CHK_NULL(curSegIDWriteBuffer);
             pipeBufAddrParams.m_segmentIdWriteBuffer = &(curSegIDWriteBuffer->OsResource);
         }
@@ -1176,7 +1177,9 @@ namespace decode{
             if (useSegMapFromPrevFrame && refFrames.CheckSegForPrimFrame(*m_av1PicParams))
             {
                 auto tempBuf = tempBuffers->GetBufferByFrameIndex(prevFrameIdx);
-                pipeBufAddrParams.m_segmentIdReadBuffer = tempBuf ? &(tempBuf->segIdBuf->OsResource) : nullptr;
+                auto segIdBuf = tempBuf ? tempBuf->segIdBuf : nullptr;
+                auto buf = segIdBuf ? segIdBuf->buffer : nullptr;
+                pipeBufAddrParams.m_segmentIdReadBuffer = buf ? &(buf->OsResource) : nullptr;
             }
         }
 
diff --git a/media_driver/media_driver_next/agnostic/common/codec/hal/dec/shared/bufferMgr/decode_reference_associated_buffer.h b/media_driver/media_driver_next/agnostic/common/codec/hal/dec/shared/bufferMgr/decode_reference_associated_buffer.h
index 6cc217bf..5d2b84da 100644
--- a/media_driver/media_driver_next/agnostic/common/codec/hal/dec/shared/bufferMgr/decode_reference_associated_buffer.h
+++ b/media_driver/media_driver_next/agnostic/common/codec/hal/dec/shared/bufferMgr/decode_reference_associated_buffer.h
@@ -1,5 +1,5 @@
 /*
-* Copyright (c) 2019-2020, Intel Corporation
+* Copyright (c) 2019-2021, Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
@@ -50,6 +50,8 @@ public:
 
     virtual BufferType *Allocate() = 0;
     virtual MOS_STATUS Resize(BufferType* &buffer) = 0;
+    virtual MOS_STATUS Deactive(BufferType* &buffer) { return MOS_STATUS_SUCCESS; }
+    virtual bool IsAvailable(BufferType* &buffer) { return true; }
     virtual void Destroy(BufferType* &buffer) = 0;
 
 protected:
@@ -80,11 +82,11 @@ public:
         }
         m_activeBuffers.clear();
 
-        for (auto& buf : m_aviableBuffers)
+        for (auto& buf : m_availableBuffers)
         {
             m_bufferOp.Destroy(buf);
         }
-        m_aviableBuffers.clear();
+        m_availableBuffers.clear();
     }
 
     //!
@@ -107,14 +109,14 @@ public:
 
         DECODE_CHK_STATUS(m_bufferOp.Init(hwInterface, allocator, basicFeature));
 
-        DECODE_ASSERT(m_aviableBuffers.empty());
+        DECODE_ASSERT(m_availableBuffers.empty());
         DECODE_ASSERT(m_activeBuffers.empty());
 
         for (uint32_t i = 0; i < initialAllocNum; i++)
         {
             BufferType *buffer = m_bufferOp.Allocate();
             DECODE_CHK_NULL(buffer);
-            m_aviableBuffers.push_back(buffer);
+            m_availableBuffers.push_back(buffer);
         }
 
         return MOS_STATUS_SUCCESS;
@@ -194,22 +196,33 @@ public:
     }
 
     //!
-    //! \brief  Return one avaliable buffer
+    //! \brief  Return one available buffer
     //! \return BufferType*
     //!         Point of buffer, nullptr if fail
     //!
-    BufferType *GetAviableBuffer()
+    BufferType *GetAvailableBuffer()
     {
         DECODE_FUNC_CALL();
-        if (m_aviableBuffers.size() == 0)
+
+        BufferType *buffer = nullptr;
+        for (auto &availableBuffer : m_availableBuffers)
         {
-            BufferType *buffer = m_bufferOp.Allocate();
+            if (m_bufferOp.IsAvailable(availableBuffer))
+            {
+                buffer = availableBuffer;
+            }
+        }
+
+        if (buffer == nullptr)
+        {
+            buffer = m_bufferOp.Allocate();
             if (buffer != nullptr)
             {
-                m_aviableBuffers.push_back(buffer);
+                m_availableBuffers.push_back(buffer);
             }
         }
-        return m_aviableBuffers[0];
+
+        return buffer;
     }
 
 protected:
@@ -224,28 +237,36 @@ protected:
     {
         DECODE_FUNC_CALL();
 
-        for (auto iter = m_activeBuffers.begin(); iter!= m_activeBuffers.end(); iter++)
+        m_currentBuffer = nullptr;
+
+        for (auto iter = m_activeBuffers.begin(); iter != m_activeBuffers.end(); iter++)
         {
             if (curFrameIdx == iter->first)
             {
+                m_currentBuffer = iter->second;
                 return MOS_STATUS_SUCCESS;
             }
         }
 
-        if (m_aviableBuffers.size() == 0)
+        // The function UpdateRefList always attach the retired buffers to end of
+        // available buffer list, reusing those buffers could improve the health with
+        // error stream, so pick up the last element of list for current frame as possible.
+        for (auto iter = m_availableBuffers.rbegin(); iter != m_availableBuffers.rend(); iter++)
         {
-            m_currentBuffer = m_bufferOp.Allocate();
-            m_bufferOp.Resize(m_currentBuffer);
+            if (m_bufferOp.IsAvailable(*iter))
+            {
+                m_currentBuffer = *iter;
+                m_availableBuffers.erase((++iter).base());
+                break;
+            }
         }
-        else
+
+        if (m_currentBuffer == nullptr)
         {
-            auto iter = m_aviableBuffers.begin();
-            m_currentBuffer = *iter;
-            m_aviableBuffers.erase(iter);
-            m_bufferOp.Resize(m_currentBuffer);
+            m_currentBuffer = m_bufferOp.Allocate();
+            DECODE_CHK_NULL(m_currentBuffer);
         }
-
-        DECODE_CHK_NULL(m_currentBuffer);
+        m_bufferOp.Resize(m_currentBuffer);
 
         auto ret = m_activeBuffers.insert(std::make_pair(curFrameIdx, m_currentBuffer));
         DECODE_CHK_COND(ret.second == false,
@@ -284,7 +305,8 @@ protected:
                 auto buffer = iter->second;
                 iter = m_activeBuffers.erase(iter);
 
-                m_aviableBuffers.push_back(buffer);
+                m_availableBuffers.push_back(buffer);
+                DECODE_CHK_STATUS(m_bufferOp.Deactive(buffer));
             }
             else
             {
@@ -328,7 +350,7 @@ protected:
 
     BufferOp                        m_bufferOp;                //!< Buffer operation
     std::map<uint32_t, BufferType*> m_activeBuffers;           //!< Active buffers corresponding to current reference frame list
-    std::vector<BufferType*>        m_aviableBuffers;          //!< Buffers in idle
+    std::vector<BufferType*>        m_availableBuffers;        //!< Buffers in idle
     BufferType*                     m_currentBuffer = nullptr; //!< Point to buffer of current picture
 };
 
-- 
2.17.1

