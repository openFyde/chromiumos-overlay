From 9df61128e7783d480a340b71971c8febac6005a2 Mon Sep 17 00:00:00 2001
From: IlyaSergeyev <ilya.sergeev@intel.com>
Date: Thu, 8 Sep 2022 12:01:23 +0800
Subject: [PATCH 2/4] FROMGIT: iHD: [VP9][Encode] Unaligned height corruption
 w/a

* [VP9][Encode] Unaligned height corruption w/a

Copy last meaning rows to the padding of the src

(cherry picked from commit a19decdaa70f3ac83f7f769db91bcbb743ec0bc4 https://github.com/intel/media-driver.git)

BUG=b:231639580
TEST= emerge- libva-intel-media-driver

Signed-off-by: Gareth Yu <gareth.yu@intel.com>
---
 .../codec/hal/codechal_vdenc_vp9_base.cpp     |  5 ++
 .../codec/hal/codechal_vdenc_vp9_g12.cpp      | 53 +++++++++++++++++++
 .../gen12/codec/hal/codechal_vdenc_vp9_g12.h  |  2 +
 3 files changed, 60 insertions(+)

diff --git a/media_driver/agnostic/common/codec/hal/codechal_vdenc_vp9_base.cpp b/media_driver/agnostic/common/codec/hal/codechal_vdenc_vp9_base.cpp
index b003752d60d0..980f3738cca9 100644
--- a/media_driver/agnostic/common/codec/hal/codechal_vdenc_vp9_base.cpp
+++ b/media_driver/agnostic/common/codec/hal/codechal_vdenc_vp9_base.cpp
@@ -4336,6 +4336,11 @@ MOS_STATUS CodechalVdencVp9State::SetHcpSrcSurfaceParams(MHW_VDBOX_SURFACE_PARAM
 
     CODECHAL_ENCODE_FUNCTION_ENTER;
 
+    if (MEDIA_IS_WA(m_waTable, Wa_Vp9UnalignedHeight))
+    {
+        m_rawSurfaceToPak->dwHeight = m_oriFrameHeight;
+    }
+
     if (m_pictureCodingType != I_TYPE)
     {
         uint8_t refPicIndex = 0, scalingIdx = 0;
diff --git a/media_driver/agnostic/gen12/codec/hal/codechal_vdenc_vp9_g12.cpp b/media_driver/agnostic/gen12/codec/hal/codechal_vdenc_vp9_g12.cpp
index 180664e1895c..104fe224c9b4 100644
--- a/media_driver/agnostic/gen12/codec/hal/codechal_vdenc_vp9_g12.cpp
+++ b/media_driver/agnostic/gen12/codec/hal/codechal_vdenc_vp9_g12.cpp
@@ -3451,6 +3451,53 @@ MOS_STATUS CodechalVdencVp9StateG12::SetPictureStructs()
     return eStatus;
 }
 
+void CodechalVdencVp9StateG12::fill_pad_with_value(PMOS_SURFACE psSurface)
+{
+    uint32_t aligned_height = MOS_ALIGN_CEIL(psSurface->dwHeight, CODEC_VP9_MIN_BLOCK_WIDTH);
+
+    // unaligned surfaces only
+    if (aligned_height == psSurface->dwHeight)
+    {
+        return;
+    }
+
+    // 4:2:0 only
+    if (psSurface->Format == Format_NV12 || psSurface->Format == Format_P010)
+    {
+        MOS_LOCK_PARAMS lockFlags;
+        MOS_ZeroMemory(&lockFlags, sizeof(MOS_LOCK_PARAMS));
+        lockFlags.WriteOnly = 1;
+
+        uint8_t *src_data   = (uint8_t *)m_osInterface->pfnLockResource(m_osInterface, &(psSurface->OsResource), &lockFlags);
+
+        uint8_t *src_data_y = src_data + psSurface->dwOffset;
+
+        uint32_t y_plane_size      = psSurface->dwPitch * psSurface->dwHeight;
+        uint32_t y_plane_size_full = psSurface->dwPitch * aligned_height;
+
+        uint8_t *src_data_y_end = src_data_y + y_plane_size;
+
+        uint32_t y_pad_rows = aligned_height - psSurface->dwHeight;
+        uint32_t y_pad_length = y_pad_rows * psSurface->dwPitch;
+
+        if (src_data_y_end > src_data_y_end - y_pad_length)
+        {
+            memcpy(src_data_y_end, src_data_y_end - y_pad_length, y_pad_length);
+        }
+
+        uint32_t uv_plane_size      = (psSurface->dwPitch * psSurface->dwHeight)/2;
+        uint32_t uv_plane_size_full = y_plane_size_full / 2;
+        uint8_t *src_data_uv_end = src_data_y + y_plane_size_full + uv_plane_size;
+
+        if (src_data_uv_end - y_pad_length > src_data_y_end)
+        {
+            memcpy(src_data_uv_end, src_data_uv_end - y_pad_length, y_pad_length);
+        }    
+
+        m_osInterface->pfnUnlockResource(m_osInterface, &(psSurface->OsResource));
+    }
+}
+
 MOS_STATUS CodechalVdencVp9StateG12::ExecutePictureLevel()
 {
     MOS_STATUS eStatus = MOS_STATUS_SUCCESS;
@@ -3888,6 +3935,12 @@ MOS_STATUS CodechalVdencVp9StateG12::ExecutePictureLevel()
 #endif
     CODECHAL_ENCODE_CHK_STATUS_RETURN(m_hcpInterface->AddHcpSurfaceCmd(&cmdBuffer, &surfaceParams[CODECHAL_HCP_SRC_SURFACE_ID]));
 
+    if (MEDIA_IS_WA(m_waTable, Wa_Vp9UnalignedHeight))
+    {
+        fill_pad_with_value(surfaceParams[CODECHAL_HCP_SRC_SURFACE_ID].psSurface);
+        fill_pad_with_value(surfaceParams[CODECHAL_HCP_DECODED_SURFACE_ID].psSurface);
+    }
+        
     if (m_pictureCodingType != I_TYPE)
     {
 #ifdef _MMC_SUPPORTED
diff --git a/media_driver/agnostic/gen12/codec/hal/codechal_vdenc_vp9_g12.h b/media_driver/agnostic/gen12/codec/hal/codechal_vdenc_vp9_g12.h
index 956a4852e563..ae6b7920c218 100644
--- a/media_driver/agnostic/gen12/codec/hal/codechal_vdenc_vp9_g12.h
+++ b/media_driver/agnostic/gen12/codec/hal/codechal_vdenc_vp9_g12.h
@@ -1313,5 +1313,7 @@ public:
         MhwMiInterface     *miInterface,
         PMOS_COMMAND_BUFFER cmdBuffer,
         uint32_t            currPass);
+
+    void fill_pad_with_value(PMOS_SURFACE psSurface);
 };
 #endif  // __CODECHAL_VDENC_VP9_G12_H__
-- 
2.31.0

