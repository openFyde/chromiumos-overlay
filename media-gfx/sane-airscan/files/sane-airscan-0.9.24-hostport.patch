commit 5d175bb067a33e0bd429964e79334d18ecc51db3
Author: Benjamin Gordon <bmgordon@chromium.org>
Date:   Mon Apr 12 10:37:53 2021 -0600

    Add quirk to force port in Host header
    
    Some devices rely on finding the port in the Host HTTP header to
    construct their response to the /eSCL/ScanJobs request.  When the port
    isn't included, the steps up to the scan job creation work, but an
    invalid redirect will be sent in the response to /eSCL/ScanJobs and then
    the scan job will never finish.
    
    Add a new quirk that forces the port to always be included in the Host
    header.  This is known to affect some Epson models, and Epson has
    indicated that this should be safe to use with all of their devices, so
    enable it for eSCL whenever the manufacturer is Epson.  The quirk itself
    is generic so that it can easily be enabled for more devices in the
    future if needed.
    
    Tested on a ET-3750.
    Fixes #136.

diff --git a/airscan-escl.c b/airscan-escl.c
index a8fc2a8..32cb96e 100644
--- a/airscan-escl.c
+++ b/airscan-escl.c
@@ -53,6 +53,7 @@ typedef struct {
     /* Miscellaneous flags */
     bool quirk_localhost;            /* Set Host: localhost in ScanJobs rq */
     bool quirk_canon_mf410_series;   /* Canon MF410 Series */
+    bool quirk_port_in_host;         /* Always set port in Host: header */
 } proto_handler_escl;
 
 /* XML namespace for XML writer
@@ -85,8 +86,13 @@ static http_query*
 escl_http_query (const proto_ctx *ctx, const char *path,
         const char *method, char *body)
 {
-    return http_query_new_relative(ctx->http, ctx->base_uri, path,
+    proto_handler_escl *escl = (proto_handler_escl*) ctx->proto;
+    http_query *query = http_query_new_relative(ctx->http, ctx->base_uri, path,
         method, body, "text/xml");
+    if (escl->quirk_port_in_host) {
+        http_query_force_port(query, true);
+    }
+    return query;
 }
 
 /* Create HTTP get query
@@ -480,6 +486,14 @@ escl_devcaps_parse (proto_handler_escl *escl,
                 escl->quirk_localhost = true;
             } else if (!strcmp(m, "MF410 Series")) {
                 escl->quirk_canon_mf410_series = true;
+            } else if (!strncasecmp(m, "EPSON ", 6)) {
+                escl->quirk_port_in_host = true;
+            }
+        } else if (xml_rd_node_name_match(xml, "scan:Manufacturer")) {
+            const char *m = xml_rd_node_value(xml);
+
+            if (!strcasecmp(m, "EPSON")) {
+                escl->quirk_port_in_host = true;
             }
         } else if (xml_rd_node_name_match(xml, "scan:Platen")) {
             xml_rd_enter(xml);
diff --git a/airscan-http.c b/airscan-http.c
index fa33d4d..69a5aaa 100644
--- a/airscan-http.c
+++ b/airscan-http.c
@@ -1971,6 +1971,7 @@ struct http_query {
     http_hdr          request_header;           /* Request header */
     http_hdr          response_header;          /* Response header */
     bool              host_inserted;            /* Host: auto-inserted */
+    bool              force_port;               /* Host: always includes port */
 
     /* HTTP redirects */
     int               redirect_count;           /* Count of redirects */
@@ -2126,6 +2127,9 @@ http_query_set_host (http_query *q)
             dport = -1;
             break;
         }
+        if (q->force_port) {
+            dport = -1;
+        }
 
         s = ip_straddr_from_sockaddr_dport(addr, dport, false);
         http_query_set_request_header(q, "Host", s.text);
@@ -2272,6 +2276,16 @@ http_query_timeout_cancel (http_query *q)
     }
 }
 
+/* Set forcing port to be added to the Host header for this query.
+ *
+ * This function may be called multiple times (each subsequent call overrides
+ * a previous one).
+ */
+void
+http_query_force_port(http_query *q, bool force_port) {
+    q->force_port = force_port;
+}
+
 /* For this particular query override on-error callback, previously
  * set by http_client_onerror()
  *
diff --git a/airscan.h b/airscan.h
index 3ab8d31..dae5810 100644
--- a/airscan.h
+++ b/airscan.h
@@ -1798,6 +1798,14 @@ http_query_new_relative(http_client *client,
 void
 http_query_timeout (http_query *q, int timeout);
 
+/* Set forcing port to be added to the Host header for this query.
+ *
+ * This function may be called multiple times (each subsequent call overrides
+ * a previous one).
+ */
+void
+http_query_force_port(http_query *q, bool force_port);
+
 /* For this particular query override on-error callback, previously
  * set by http_client_onerror()
  *
