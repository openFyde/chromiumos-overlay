#!/usr/bin/env python3
# Copyright 2022 The ChromiumOS Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
"""Writes allowlisted crate names/versions into our ebuild.

This is intended to be the primary method for keeping our ebuild's allowlist
up-to-date.

FIXME(b/240953811): Remove this once our migration is done.
"""

import argparse
import collections
import json
import logging
from pathlib import Path
import re
import subprocess
import sys
from typing import List

import migration_utils


# Crates which are allowlisted because they don't exist in dev-rust, and
# because their users all depend directly on dev-rust/third-party-crates-src:=
# (see b/247596883#comment3 for why this is important).
EXPLICITLY_ALLOWLISTED_CRATES = {
    "addr2line-0.14.1",
    "adler-0.2.3",
    "bytemuck-1.12.1",
    "gimli-0.23.0",
    "object-0.23.0",
    "quote-0.3.15",
    "redox_syscall-0.2.4",
    "syn-0.11.11",
    "unicode-xid-0.0.4",
}


def is_unmigrated_third_party_crate(ebuild_contents: str):
    """Returns True if this ebuild is an unmigrated third-party crate."""
    return migration_utils.MIGRATED_CRATE_MARKER not in ebuild_contents


def find_dev_rust_crates(dev_rust: Path) -> List[str]:
    """Returns all dev-rust crates which haven't been migrated yet."""
    results = set()
    rev = re.compile(r"-r\d+$")
    for subdir in dev_rust.iterdir():
        if not subdir.is_dir():
            continue

        dirents = list(subdir.iterdir())
        crate_name = subdir.name
        if any(x.name.endswith("-9999.ebuild") for x in dirents):
            logging.info("Skipping %s; it is a workon crate", crate_name)
            continue

        for maybe_ebuild in dirents:
            if maybe_ebuild.suffix != ".ebuild" or maybe_ebuild.is_symlink():
                continue

            ebuild_contents = maybe_ebuild.read_text(encoding="utf-8")
            if is_unmigrated_third_party_crate(ebuild_contents):
                name = rev.sub("", maybe_ebuild.stem)
                # We have rand_core_transitional in dev-rust/, which actually
                # just installs rand_core. Account for that here.
                name = name.replace("rand_core_transitional", "rand_core")
                results.add(name)

    return sorted(results)


def update_allowlist(ebuild: Path, new_allowlist: List[str]):
    """Updates third-party-crates-src with new crate allowlists.

    Args:
        ebuild: ebuild to update.
        new_allowlist: Versions of crates to allow the installation of.
    """
    new_ebuild_lines = [
        x.rstrip() for x in ebuild.read_text(encoding="utf-8").splitlines()
    ]

    disclaimer_lines = [
        "\t# NOTE: This list was generated by",
        "\t# ${FILESDIR}/write_allowlisted_crate_versions.py. Any",
        "\t# modifications may be overwritten.",
    ]

    # We always want quoting here, and crate names/versions can't have quotes.
    allowlist_lines = [f'\t"{x}"' for x in new_allowlist]
    start = new_ebuild_lines.index("ALLOWED_CRATE_VERSIONS=(")
    end = new_ebuild_lines.index(")", start)

    new_ebuild_lines = (
        new_ebuild_lines[: start + 1]
        + disclaimer_lines
        + allowlist_lines
        + new_ebuild_lines[end:]
    )

    # Ensure there's exactly one newline at the end of this ebuild, to keep
    # presubmits happy.
    ebuild_text = "\n".join(new_ebuild_lines).rstrip() + "\n"
    ebuild.write_text(ebuild_text, encoding="utf-8")


def get_parser():
    """Constructs our arg parser."""
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    my_location = Path(__file__).parent
    dev_rust = my_location.parent.parent
    parser.add_argument("--dev-rust", type=Path, default=dev_rust)
    parser.add_argument(
        "--third-party-crates-ebuild",
        type=Path,
        default=my_location.parent / "third-party-crates-src-9999.ebuild",
    )
    parser.add_argument(
        "--debug",
        action="store_true",
        help="Use debug logging.",
    )
    parser.add_argument(
        "--rust-crates-path",
        type=Path,
        default=dev_rust.parent.parent / "rust_crates",
    )
    return parser


def crate_name_from_vendor_dir(dir_name: str) -> str:
    """Returns the name of the crate designated by dir_name."""
    # See https://semver.org/ for a specification of these versions.
    no_meta = dir_name.split("+", 1)[0]
    no_beta = no_meta.replace("-beta.", "")
    return no_beta.rsplit("-", 1)[0]


def allowlist_entry_to_cargo_id_prefix(entry: str) -> str:
    """Converts an allowlist entry into the prefix for a cargo metadata ID."""
    i = entry.find("+")
    if i == -1:
        i = len(entry)
    last_dash = entry.rindex("-", 0, i)
    return entry[:last_dash] + " " + entry[last_dash + 1 :]


def cargo_id_to_vendored_crate_name(cargo_id: str) -> str:
    """Converts a cargo ID to an allowlist-like str."""
    assert "https://github.com/rust-lang/crates.io-index" in cargo_id, cargo_id
    return cargo_id.split(" (", 1)[0].replace(" ", "-")


def verify_dependencies(
    rust_crates_path: Path,
    new_allowlist: List[str],
    dev_rust_crate_versions: List[str],
):
    """Verifies that our rust_crates exports have dependencies exported."""
    assert new_allowlist, "Expected allowlist to have any entries at all."

    logging.info("Running `cargo metadata`...")
    output = subprocess.run(
        ["cargo", "metadata", "--format-version=1"],
        cwd=rust_crates_path / "projects",
        capture_output=True,
        check=True,
        encoding="utf-8",
    ).stdout

    logging.info("Resolving metadata")
    resolved_metadata = json.loads(output)["resolve"]
    dependencies = {
        cargo_id_to_vendored_crate_name(pkg["id"]): [
            cargo_id_to_vendored_crate_name(x) for x in pkg["dependencies"]
        ]
        for pkg in resolved_metadata["nodes"]
        # This metadata will have entries for the pseudo-crates in
        # rust_crates/projects. Filter those out.
        if "src/third_party/rust_crates/projects" not in pkg["id"]
    }

    transitive_deps = set()
    dependency_stack = list(new_allowlist)
    while dependency_stack:
        item = dependency_stack.pop()
        if item not in transitive_deps:
            transitive_deps.add(item)
            dependency_stack += dependencies[item]

    immediately_missing_deps = sorted(transitive_deps - set(new_allowlist))

    dev_rust_crate_versions_set = set(dev_rust_crate_versions)
    dev_rust_version_map = collections.defaultdict(list)
    for crate in dev_rust_crate_versions:
        crate_name, version = crate.rsplit("-", 1)
        dev_rust_version_map[crate_name].append(version)

    missing_deps = []
    for dep in immediately_missing_deps:
        if dep in dev_rust_crate_versions_set:
            logging.info("Found transitive dep %s in dev-rust", dep)
            continue

        crate_name = crate_name_from_vendor_dir(dep)
        version = dep.split("+", 1)[0].rsplit("-", 1)[1]
        for opt in dev_rust_version_map[crate_name]:
            if migration_utils.is_semver_compatible_upgrade(
                version, opt
            ) or migration_utils.is_semver_compatible_upgrade(opt, version):
                logging.info(
                    "Found semver-compatible dep %s-%s in dev-rust for %s",
                    crate_name,
                    opt,
                    dep,
                )
                break
        else:
            missing_deps.append(dep)

    if not missing_deps:
        logging.info("Transitive dependencies are OK")
        return

    logging.error(
        "Missing dependencies; please verify and add to the allowlist: %s",
        missing_deps,
    )
    raise ValueError("Depgraph is incorrect. See above logs.")


def main(argv: List[str]):
    """Main function."""
    opts = get_parser().parse_args(argv)
    logging.basicConfig(
        format=">> %(asctime)s: %(levelname)s: %(filename)s:%(lineno)d: "
        "%(message)s",
        level=logging.DEBUG if opts.debug else logging.INFO,
    )

    non_migrated_crates = find_dev_rust_crates(opts.dev_rust)
    non_migrated_crate_names = set(
        x.rsplit("-", 1)[0] for x in non_migrated_crates
    )
    vendor_dir = opts.rust_crates_path / "vendor"
    new_allowlist = []
    for crate_dir in vendor_dir.iterdir():
        if not crate_dir.is_dir():
            continue

        crate_dir_name = crate_dir.name
        crate_name = crate_name_from_vendor_dir(crate_dir_name)
        if (
            crate_name in non_migrated_crate_names
            and crate_dir_name not in EXPLICITLY_ALLOWLISTED_CRATES
        ):
            logging.debug(
                "Skipping %s, since it is not yet migrated", crate_dir_name
            )
            continue
        new_allowlist.append(crate_dir_name)

    new_allowlist.sort()

    logging.info("Allowlist generated successfully. Verifying dependencies...")
    verify_dependencies(
        opts.rust_crates_path, new_allowlist, non_migrated_crates
    )
    update_allowlist(opts.third_party_crates_ebuild, new_allowlist)


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
