diff --git a/clang/cmake/caches/SoteriaCompilerRT.cmake b/clang/cmake/caches/SoteriaCompilerRT.cmake
new file mode 100644
index 000000000000..38d5d056ced3
--- /dev/null
+++ b/clang/cmake/caches/SoteriaCompilerRT.cmake
@@ -0,0 +1,36 @@
+# CMakeCache for the Soteria compiler-rt build.
+if(NOT DEFINED SOTERIA_LLVM_INSTALL)
+  message(FATAL_ERROR "Specify the SOTERIA_LLVM_INSTALL variable.")
+endif()
+
+if(NOT DEFINED RISCV_GNU_TOOLCHAIN)
+  message(FATAL_ERROR "Specify the RISCV_GNU_TOOLCHAIN variable.")
+endif()
+
+set(CMAKE_C_COMPILER "${SOTERIA_LLVM_INSTALL}/bin/clang" CACHE STRING "")
+set(CMAKE_CXX_COMPILER "${SOTERIA_LLVM_INSTALL}/bin/clang++" CACHE STRING "")
+set(CMAKE_INSTALL_PREFIX "${SOTERIA_LLVM_INSTALL}" CACHE STRING "")
+
+set(CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN "${RISCV_GNU_TOOLCHAIN}" CACHE STRING "")
+set(CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN "${RISCV_GNU_TOOLCHAIN}" CACHE STRING "")
+set(CMAKE_SYSROOT "${RISCV_GNU_TOOLCHAIN}/riscv32-unknown-elf" CACHE STRING "")
+
+set(_SOTERIA_TARGET "riscv32-unknown-elf")
+set(CMAKE_C_COMPILER_TARGET "${_SOTERIA_TARGET}" CACHE STRING "")
+set(CMAKE_CXX_COMPILER_TARGET "${_SOTERIA_TARGET}" CACHE STRING "")
+set(CMAKE_ASM_COMPILER_TARGET "${_SOTERIA_TARGET}" CACHE STRING "")
+
+set(_SOTERIA_RT_FLAGS "-march=rv32imc -mabi=ilp32 -O3")
+set(CMAKE_C_FLAGS "${_SOTERIA_RT_FLAGS}" CACHE STRING "")
+set(CMAKE_CXX_FLAGS "${_SOTERIA_RT_FLAGS}" CACHE STRING "")
+set(CMAKE_ASM_FLAGS "${_SOTERIA_RT_FLAGS}" CACHE STRING "")
+
+set(COMPILER_RT_BUILD_BUILTINS OFF CACHE BOOL "")
+set(COMPILER_RT_BUILD_CRT OFF CACHE BOOL "")
+set(COMPILER_RT_BUILD_SANITIZERS ON CACHE BOOL "")
+set(COMPILER_RT_BUILD_XRAY OFF CACHE BOOL "")
+set(COMPILER_RT_BUILD_LIBFUZZER OFF CACHE BOOL "")
+set(COMPILER_RT_BUILD_PROFILE OFF CACHE BOOL "")
+
+set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR ON CACHE BOOL "")
+set(COMPILER_RT_DEFAULT_TARGET_ONLY ON CACHE BOOL "")
diff --git a/clang/cmake/caches/SoteriaDistribution-stage2.cmake b/clang/cmake/caches/SoteriaDistribution-stage2.cmake
new file mode 100644
index 000000000000..81ff2b1d9ea6
--- /dev/null
+++ b/clang/cmake/caches/SoteriaDistribution-stage2.cmake
@@ -0,0 +1,29 @@
+# CMakeCache for the second stage of the distribution bootstrap build.
+
+set(LLVM_ENABLE_PROJECTS "clang;lld" CACHE STRING "" FORCE)
+set(LLVM_ENABLE_RUNTIMES "" CACHE STRING "" FORCE)
+
+set(LLVM_TARGETS_TO_BUILD "RISCV" CACHE STRING "")
+set(LLVM_DEFAULT_TARGET_TRIPLE "riscv32-unknown-elf" CACHE STRING "")
+
+set(LLVM_PARALLEL_LINK_JOBS 4 CACHE STRING "")
+
+set(CMAKE_BUILD_TYPE RelWithDebInfo CACHE STRING "")
+set(CMAKE_C_FLAGS_RELWITHDEBINFO "-O3 -gline-tables-only -DNDEBUG" CACHE STRING "")
+set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "-O3 -gline-tables-only -DNDEBUG" CACHE STRING "")
+
+# setup toolchain
+set(LLVM_INSTALL_TOOLCHAIN_ONLY ON CACHE BOOL "")
+set(LLVM_TOOLCHAIN_TOOLS
+  llvm-ar
+  llvm-nm
+  llvm-mc
+  llvm-objdump
+  CACHE STRING "")
+
+set(LLVM_DISTRIBUTION_COMPONENTS
+  clang
+  clang-resource-headers
+  lld
+  ${LLVM_TOOLCHAIN_TOOLS}
+  CACHE STRING "")
diff --git a/clang/cmake/caches/SoteriaDistribution.cmake b/clang/cmake/caches/SoteriaDistribution.cmake
new file mode 100644
index 000000000000..39d74f48b87a
--- /dev/null
+++ b/clang/cmake/caches/SoteriaDistribution.cmake
@@ -0,0 +1,32 @@
+# CMakeCache for the distribution bootstrap build.
+
+#Enable LLVM projects and runtimes
+set(LLVM_ENABLE_PROJECTS "clang;lld" CACHE STRING "")
+set(LLVM_ENABLE_RUNTIMES "compiler-rt;libcxx;libcxxabi" CACHE STRING "")
+
+# Only build the native target in stage1 since it is a throwaway build.
+set(LLVM_TARGETS_TO_BUILD Native CACHE STRING "")
+
+# Optimize the stage1 compiler, but don't LTO it because that wastes time.
+set(CMAKE_BUILD_TYPE Release CACHE STRING "")
+
+# Setup vendor-specific settings.
+set(PACKAGE_VENDOR LLVM.org CACHE STRING "")
+
+set(LLVM_PARALLEL_LINK_JOBS 4 CACHE STRING "")
+
+set(CLANG_BOOTSTRAP_PASSTHROUGH CMAKE_INSTALL_PREFIX CACHE STRING "")
+
+# Expose stage2 targets through the stage1 build configuration.
+set(CLANG_BOOTSTRAP_TARGETS
+  distribution
+  install-distribution
+  clang CACHE STRING "")
+
+# Setup the bootstrap build.
+set(CLANG_ENABLE_BOOTSTRAP ON CACHE BOOL "")
+
+# Stage-2 configuration.
+set(CLANG_BOOTSTRAP_CMAKE_ARGS
+    -C ${CMAKE_CURRENT_LIST_DIR}/SoteriaDistribution-stage2.cmake
+    CACHE STRING "")
diff --git a/clang/include/clang/Basic/Attr.td b/clang/include/clang/Basic/Attr.td
index d61f3583281d..b709ed89b02a 100644
--- a/clang/include/clang/Basic/Attr.td
+++ b/clang/include/clang/Basic/Attr.td
@@ -3910,6 +3910,13 @@ def ObjCExternallyRetained : InheritableAttr {
   let Documentation = [ObjCExternallyRetainedDocs];
 }
 
+def Soteria : InheritableAttr {
+  let Spellings = [GCC<"soteria">];
+  let Subjects = SubjectList<[Function]>;
+  let Args = [StringArgument<"Feature">];
+  let Documentation = [SoteriaDocs];
+}
+
 def NoBuiltin : Attr {
   let Spellings = [Clang<"no_builtin">];
   let Args = [VariadicStringArgument<"BuiltinNames">];
diff --git a/clang/include/clang/Basic/AttrDocs.td b/clang/include/clang/Basic/AttrDocs.td
index 5c84e2fc5b77..8ec8029b7029 100644
--- a/clang/include/clang/Basic/AttrDocs.td
+++ b/clang/include/clang/Basic/AttrDocs.td
@@ -6035,6 +6035,13 @@ attribute `clang_builtin_alias`.
   }];
 }
 
+def SoteriaDocs : Documentation {
+  let Category = DocCatFunction;
+  let Content = [{
+This attribute is used to enable Soteria security features.
+  }];
+}
+
 def NoBuiltinDocs : Documentation {
   let Category = DocCatFunction;
   let Content = [{
diff --git a/clang/include/clang/Basic/BuiltinsSoteria.def b/clang/include/clang/Basic/BuiltinsSoteria.def
new file mode 100644
index 000000000000..4caa4aa356a7
--- /dev/null
+++ b/clang/include/clang/Basic/BuiltinsSoteria.def
@@ -0,0 +1,29 @@
+//===-- BuiltinsSoteria.def - Soteria Builtin function database --*- C++ -*-==//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines the Soteria-specific builtin function database. Users of
+// this file must define the BUILTIN macro to make use of this information.
+//
+//===----------------------------------------------------------------------===//
+
+// The format of this database matches clang/Basic/Builtins.def.
+
+// The builtins below are not autogenerated from iset.py.
+// Make sure you do not overwrite these.
+
+#if defined(BUILTIN) && !defined(TARGET_BUILTIN)
+#   define TARGET_BUILTIN(ID, TYPE, ATTRS, FEATURE) BUILTIN(ID, TYPE, ATTRS)
+#endif
+
+TARGET_BUILTIN(__builtin_riscv_soteria_grev, "iii", "nc", "xsoteria")
+TARGET_BUILTIN(__builtin_riscv_soteria_bitc, "iii", "nc", "xsoteria")
+TARGET_BUILTIN(__builtin_riscv_soteria_bits, "iii", "nc", "xsoteria")
+TARGET_BUILTIN(__builtin_riscv_soteria_fls, "ii", "nc", "xsoteria")
+
+#undef BUILTIN
+#undef TARGET_BUILTIN
diff --git a/clang/include/clang/Basic/TargetBuiltins.h b/clang/include/clang/Basic/TargetBuiltins.h
index d8ad9858d8c8..91e78085ec62 100644
--- a/clang/include/clang/Basic/TargetBuiltins.h
+++ b/clang/include/clang/Basic/TargetBuiltins.h
@@ -138,12 +138,23 @@ namespace clang {
   };
   }
 
+  namespace RISCVSoteria {
+  enum {
+    LastRVVBuiltin = RISCVVector::FirstTSBuiltin - 1,
+#define BUILTIN(ID, TYPE, ATTRS) BI##ID,
+#include "clang/Basic/BuiltinsSoteria.def"
+    FirstTSBuiltin,
+  };
+  }
+
   /// RISCV builtins
   namespace RISCV {
   enum {
     LastTIBuiltin = clang::Builtin::FirstTSBuiltin - 1,
     FirstRVVBuiltin = clang::Builtin::FirstTSBuiltin,
     LastRVVBuiltin = RISCVVector::FirstTSBuiltin - 1,
+    FirstSoteriaBuiltin = RISCVVector::FirstTSBuiltin,
+    LastSoteriaBuiltin = RISCVSoteria::FirstTSBuiltin - 1,
 #define BUILTIN(ID, TYPE, ATTRS) BI##ID,
 #include "clang/Basic/BuiltinsRISCV.def"
     LastTSBuiltin
diff --git a/clang/lib/Basic/Targets/RISCV.cpp b/clang/lib/Basic/Targets/RISCV.cpp
index 7e6c0620385a..7c009daf3747 100644
--- a/clang/lib/Basic/Targets/RISCV.cpp
+++ b/clang/lib/Basic/Targets/RISCV.cpp
@@ -192,9 +192,17 @@ void RISCVTargetInfo::getTargetDefines(const LangOptions &Opts,
 
   if (ISAInfo->hasExtension("zve32x"))
     Builder.defineMacro("__riscv_vector");
+
+  if (ISAInfo->hasExtension("xsoteria"))
+    Builder.defineMacro("__soteria");
 }
 
 const Builtin::Info RISCVTargetInfo::BuiltinInfo[] = {
+#define BUILTIN(ID, TYPE, ATTRS)                                               \
+  {#ID, TYPE, ATTRS, nullptr, ALL_LANGUAGES, nullptr},
+#define TARGET_BUILTIN(ID, TYPE, ATTRS, FEATURE)                               \
+  {#ID, TYPE, ATTRS, nullptr, ALL_LANGUAGES, FEATURE},
+#include "clang/Basic/BuiltinsSoteria.def"
 #define BUILTIN(ID, TYPE, ATTRS)                                               \
   {#ID, TYPE, ATTRS, nullptr, ALL_LANGUAGES, nullptr},
 #define TARGET_BUILTIN(ID, TYPE, ATTRS, FEATURE)                               \
diff --git a/clang/lib/CodeGen/CGCall.cpp b/clang/lib/CodeGen/CGCall.cpp
index dfa78bf59c65..bdb8e93a18a6 100644
--- a/clang/lib/CodeGen/CGCall.cpp
+++ b/clang/lib/CodeGen/CGCall.cpp
@@ -2278,6 +2278,12 @@ void CodeGenModule::ConstructAttributeList(StringRef Name,
     // CPU/feature overrides.  addDefaultFunctionDefinitionAttributes
     // handles these separately to set them based on the global defaults.
     GetCPUAndFeaturesAttributes(CalleeInfo.getCalleeDecl(), FuncAttrs);
+
+    if (TargetDecl && TargetDecl->hasAttr<SoteriaAttr>()) {
+      FuncAttrs.addAttribute("soteria",
+                             TargetDecl->getAttr<SoteriaAttr>()->getFeature());
+      FuncAttrs.addAttribute(llvm::Attribute::NoInline);
+    }
   }
 
   // Collect attributes from arguments and return values.
diff --git a/clang/lib/CodeGen/CodeGenFunction.h b/clang/lib/CodeGen/CodeGenFunction.h
index 672acd844525..3b83ee094203 100644
--- a/clang/lib/CodeGen/CodeGenFunction.h
+++ b/clang/lib/CodeGen/CodeGenFunction.h
@@ -4247,6 +4247,7 @@ public:
   llvm::Value *EmitAMDGPUBuiltinExpr(unsigned BuiltinID, const CallExpr *E);
   llvm::Value *EmitSystemZBuiltinExpr(unsigned BuiltinID, const CallExpr *E);
   llvm::Value *EmitNVPTXBuiltinExpr(unsigned BuiltinID, const CallExpr *E);
+  llvm::Value *EmitRISCVBuiltinExpr(unsigned BuiltinID, const CallExpr *E);
   llvm::Value *EmitWebAssemblyBuiltinExpr(unsigned BuiltinID,
                                           const CallExpr *E);
   llvm::Value *EmitHexagonBuiltinExpr(unsigned BuiltinID, const CallExpr *E);
diff --git a/clang/lib/CodeGen/CodeGenModule.cpp b/clang/lib/CodeGen/CodeGenModule.cpp
index d87692face2a..8db229428405 100644
--- a/clang/lib/CodeGen/CodeGenModule.cpp
+++ b/clang/lib/CodeGen/CodeGenModule.cpp
@@ -2034,6 +2034,12 @@ void CodeGenModule::SetLLVMFunctionAttributesForDefinition(const Decl *D,
     }
   }
 
+  if (D->hasAttr<SoteriaAttr>()) {
+    const auto* Attr = D->getAttr<SoteriaAttr>();
+    B.addAttribute("soteria", Attr->getFeature());
+    B.addAttribute(llvm::Attribute::NoInline);
+  }
+
   // Add other optimization related attributes if we are optimizing this
   // function.
   if (!D->hasAttr<OptimizeNoneAttr>()) {
diff --git a/clang/lib/Driver/ToolChain.cpp b/clang/lib/Driver/ToolChain.cpp
index 7a4319ea680f..6f5c8004a775 100644
--- a/clang/lib/Driver/ToolChain.cpp
+++ b/clang/lib/Driver/ToolChain.cpp
@@ -1088,6 +1088,9 @@ SanitizerMask ToolChain::getSupportedSanitizers() const {
     Res |= SanitizerKind::ShadowCallStack;
   if (getTriple().isAArch64(64))
     Res |= SanitizerKind::MemTag;
+  // Enable HWASAN even for bare metal RISCV
+  if (getTriple().isRISCV())
+    Res |= SanitizerKind::HWAddress;
   return Res;
 }
 
diff --git a/clang/lib/Driver/ToolChains/RISCVToolchain.cpp b/clang/lib/Driver/ToolChains/RISCVToolchain.cpp
index 3491de22d371..529835c7043f 100644
--- a/clang/lib/Driver/ToolChains/RISCVToolchain.cpp
+++ b/clang/lib/Driver/ToolChains/RISCVToolchain.cpp
@@ -144,6 +144,12 @@ std::string RISCVToolChain::computeSysRoot() const {
   return std::string(SysRootDir.str());
 }
 
+SanitizerMask RISCVToolChain::getSupportedSanitizers() const {
+  SanitizerMask Res = ToolChain::getSupportedSanitizers();
+  Res |= SanitizerKind::HWAddress;
+  return Res;
+}
+
 void RISCV::Linker::ConstructJob(Compilation &C, const JobAction &JA,
                                  const InputInfo &Output,
                                  const InputInfoList &Inputs,
diff --git a/clang/lib/Driver/ToolChains/RISCVToolchain.h b/clang/lib/Driver/ToolChains/RISCVToolchain.h
index 46b94bdb54e0..19fc6ba33dac 100644
--- a/clang/lib/Driver/ToolChains/RISCVToolchain.h
+++ b/clang/lib/Driver/ToolChains/RISCVToolchain.h
@@ -34,6 +34,7 @@ public:
   void
   addLibStdCxxIncludePaths(const llvm::opt::ArgList &DriverArgs,
                            llvm::opt::ArgStringList &CC1Args) const override;
+  SanitizerMask getSupportedSanitizers() const override;
 
 protected:
   Tool *buildLinker() const override;
diff --git a/clang/test/CodeGen/builtins-soteria.c b/clang/test/CodeGen/builtins-soteria.c
new file mode 100644
index 000000000000..1a7a1b632626
--- /dev/null
+++ b/clang/test/CodeGen/builtins-soteria.c
@@ -0,0 +1,53 @@
+// RUN: %clang_cc1 -triple=riscv32-unknown-none -target-feature +xsoteria -O3 \
+// RUN:   -S -o - %s | FileCheck %s -check-prefix=RV32S
+
+int intrinsics(int x) {
+  // RV32S-LABEL: intrinsics:
+
+  int v1 = __builtin_riscv_soteria_grev(x, x);
+  // RV32S: grev
+
+  int v2 = __builtin_riscv_soteria_grev(x, 1);
+  // RV32S: grevi
+
+  int v3 = __builtin_riscv_soteria_bitc(x, x);
+  // RV32S: bitc
+
+  int v4 = __builtin_riscv_soteria_bitc(x, 2);
+  // RV32S: bitci
+
+  int v5 = __builtin_riscv_soteria_bits(x, x);
+  // RV32S: bits
+
+  int v6 = __builtin_riscv_soteria_bits(x, 3);
+  // RV32S: bitsi
+
+  int v7 = __builtin_popcount(x);
+  // RV32S: pcnt
+
+  int v8 = __builtin_clz(x);
+  // RV32S: clz
+
+  int v9 = __builtin_riscv_soteria_fls(x);
+  // RV32S: fls
+
+  return v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8 + v9;
+}
+
+int bitc_pattern(int a, int b) {
+  // RV32S-LABEL: bitc_pattern:
+
+  return a & ~(1 << b);
+  // RV32S-NOT: and
+  // RV32S: bitc a0, a0, a1
+  // RV32S-NEXT: ret
+}
+
+int bits_pattern(int a, int b) {
+  // RV32S-LABEL: bits_pattern:
+
+  return a | (1 << b);
+  // RV32S-NOT: or
+  // RV32S: bits a0, a0, a1
+  // RV32S-NEXT: ret
+}
diff --git a/clang/test/Driver/riscv-fsanitize.c b/clang/test/Driver/riscv-fsanitize.c
new file mode 100644
index 000000000000..9caa88bdeac3
--- /dev/null
+++ b/clang/test/Driver/riscv-fsanitize.c
@@ -0,0 +1,6 @@
+// RUN: %clang -fsyntax-only -### -target riscv32-unknown-elf \
+// RUN:   -fsanitize=hwaddress %s 2>&1 | FileCheck %s
+// RUN: %clang -fsyntax-only -### -target riscv64-unknown-elf \
+// RUN:   -fsanitize=hwaddress %s 2>&1 | FileCheck %s
+// CHECK-NOT: unsupported option '-fsanitize=hwaddress'
+
diff --git a/clang/test/Misc/pragma-attribute-supported-attributes-list.test b/clang/test/Misc/pragma-attribute-supported-attributes-list.test
index 64e2bf619004..dbf344178bc9 100644
--- a/clang/test/Misc/pragma-attribute-supported-attributes-list.test
+++ b/clang/test/Misc/pragma-attribute-supported-attributes-list.test
@@ -162,6 +162,7 @@
 // CHECK-NEXT: ScopedLockable (SubjectMatchRule_record)
 // CHECK-NEXT: Section (SubjectMatchRule_function, SubjectMatchRule_variable_is_global, SubjectMatchRule_objc_method, SubjectMatchRule_objc_property)
 // CHECK-NEXT: SetTypestate (SubjectMatchRule_function_is_member)
+// CHECK-NEXT: Soteria (SubjectMatchRule_function)
 // CHECK-NEXT: SpeculativeLoadHardening (SubjectMatchRule_function, SubjectMatchRule_objc_method)
 // CHECK-NEXT: StandaloneDebug (SubjectMatchRule_record)
 // CHECK-NEXT: SwiftAsync (SubjectMatchRule_function, SubjectMatchRule_objc_method)
diff --git a/compiler-rt/cmake/Modules/AllSupportedArchDefs.cmake b/compiler-rt/cmake/Modules/AllSupportedArchDefs.cmake
index a1da35b0ac4b..f307c96db252 100644
--- a/compiler-rt/cmake/Modules/AllSupportedArchDefs.cmake
+++ b/compiler-rt/cmake/Modules/AllSupportedArchDefs.cmake
@@ -56,6 +56,7 @@ else()
 endif()
 set(ALL_MSAN_SUPPORTED_ARCH ${X86_64} ${MIPS64} ${ARM64} ${PPC64} ${S390X})
 set(ALL_HWASAN_SUPPORTED_ARCH ${X86_64} ${ARM64})
+set(ALL_HWASAN_MINIMAL_SUPPORTED_ARCH ${RISCV32})
 set(ALL_MEMPROF_SUPPORTED_ARCH ${X86_64})
 set(ALL_PROFILE_SUPPORTED_ARCH ${X86} ${X86_64} ${ARM32} ${ARM64} ${PPC32} ${PPC64}
     ${MIPS32} ${MIPS64} ${S390X} ${SPARC} ${SPARCV9} ${HEXAGON}
diff --git a/compiler-rt/cmake/config-ix.cmake b/compiler-rt/cmake/config-ix.cmake
index 9077e8f9ffe0..e0614ae35452 100644
--- a/compiler-rt/cmake/config-ix.cmake
+++ b/compiler-rt/cmake/config-ix.cmake
@@ -586,6 +586,7 @@ if(APPLE)
   list_intersect(HWASAN_SUPPORTED_ARCH
     ALL_HWASAN_SUPPORTED_ARCH
     SANITIZER_COMMON_SUPPORTED_ARCH)
+  set(HWASAN_MINIMAL_SUPPORTED_ARCH)
   list_intersect(MEMPROF_SUPPORTED_ARCH
     ALL_MEMPROF_SUPPORTED_ARCH
     SANITIZER_COMMON_SUPPORTED_ARCH)
@@ -639,6 +640,7 @@ else()
   filter_available_targets(LSAN_SUPPORTED_ARCH ${ALL_LSAN_SUPPORTED_ARCH})
   filter_available_targets(MSAN_SUPPORTED_ARCH ${ALL_MSAN_SUPPORTED_ARCH})
   filter_available_targets(HWASAN_SUPPORTED_ARCH ${ALL_HWASAN_SUPPORTED_ARCH})
+  filter_available_targets(HWASAN_MINIMAL_SUPPORTED_ARCH ${ALL_HWASAN_MINIMAL_SUPPORTED_ARCH})
   filter_available_targets(MEMPROF_SUPPORTED_ARCH ${ALL_MEMPROF_SUPPORTED_ARCH})
   filter_available_targets(PROFILE_SUPPORTED_ARCH ${ALL_PROFILE_SUPPORTED_ARCH})
   filter_available_targets(TSAN_SUPPORTED_ARCH ${ALL_TSAN_SUPPORTED_ARCH})
@@ -686,7 +688,7 @@ if(COMPILER_RT_SUPPORTED_ARCH)
 endif()
 message(STATUS "Compiler-RT supported architectures: ${COMPILER_RT_SUPPORTED_ARCH}")
 
-set(ALL_SANITIZERS asan;dfsan;msan;hwasan;tsan;safestack;cfi;scudo;ubsan_minimal;gwp_asan)
+set(ALL_SANITIZERS asan;dfsan;msan;hwasan;tsan;safestack;cfi;scudo;ubsan_minimal;gwp_asan;hwasan_minimal)
 set(COMPILER_RT_SANITIZERS_TO_BUILD all CACHE STRING
     "sanitizers to build if supported on the target (all;${ALL_SANITIZERS})")
 list_replace(COMPILER_RT_SANITIZERS_TO_BUILD all "${ALL_SANITIZERS}")
@@ -748,6 +750,12 @@ else()
   set(COMPILER_RT_HAS_HWASAN FALSE)
 endif()
 
+if (HWASAN_MINIMAL_SUPPORTED_ARCH)
+  set(COMPILER_RT_HAS_HWASAN_MINIMAL TRUE)
+else()
+  set(COMPILER_RT_HAS_HWASAN_MINIMAL FALSE)
+endif()
+
 if (COMPILER_RT_HAS_SANITIZER_COMMON AND MEMPROF_SUPPORTED_ARCH AND
     OS_NAME MATCHES "Linux")
   set(COMPILER_RT_HAS_MEMPROF TRUE)
diff --git a/compiler-rt/lib/hwasan_minimal/CMakeLists.txt b/compiler-rt/lib/hwasan_minimal/CMakeLists.txt
new file mode 100644
index 000000000000..d1b359f17e5e
--- /dev/null
+++ b/compiler-rt/lib/hwasan_minimal/CMakeLists.txt
@@ -0,0 +1,32 @@
+include_directories(..)
+
+# Runtime library sources and build flags.
+set(HWASAN_MINIMAL_RTL_SOURCES
+  hwasan.cpp
+  hwasan_poisoning.cpp
+  sanitizer_libc.cpp
+  hwasan_memintrinsics.cpp
+  )
+
+set(HWASAN_MINIMAL_RTL_HEADERS
+  hwasan.h
+  hwasan_interface_internal.h
+  hwasan_mapping.h
+  hwasan_poisoning.h
+  )
+
+# Static runtime library.
+add_compiler_rt_component(hwasan-minimal)
+
+add_compiler_rt_object_libraries(RTHwasan_minimal
+  ARCHS ${HWASAN_MINIMAL_SUPPORTED_ARCH}
+  SOURCES ${HWASAN_MINIMAL_RTL_SOURCES}
+  ADDITIONAL_HEADERS ${HWASAN_MINIMAL_RTL_HEADERS})
+
+foreach(arch ${HWASAN_MINIMAL_SUPPORTED_ARCH})
+  add_compiler_rt_runtime(clang_rt.hwasan_minimal
+    STATIC
+    ARCHS ${arch}
+    OBJECT_LIBS RTHwasan_minimal
+    PARENT_TARGET hwasan-minimal)
+endforeach()
diff --git a/compiler-rt/lib/hwasan_minimal/README.txt b/compiler-rt/lib/hwasan_minimal/README.txt
new file mode 100644
index 000000000000..3d15f9a88a3b
--- /dev/null
+++ b/compiler-rt/lib/hwasan_minimal/README.txt
@@ -0,0 +1,11 @@
+This directory contains a stripped-down hwasan runtime. The original goal
+is to evaluate hwasan in a RISCV processor running a bare-metal OS.
+
+The original files were copied from the sibling directory ../hwasan.
+As more features are needed, more code will be copied from the original
+directory. Eventually, if possible, this directory should be merged into
+the original one (e.g. using conditional compilation).
+
+Besides stripping down functionality, additional changes were made to break
+dependencies mainly with the sanitizer_common library.
+
diff --git a/compiler-rt/lib/hwasan_minimal/hwasan.cpp b/compiler-rt/lib/hwasan_minimal/hwasan.cpp
new file mode 100644
index 000000000000..fc1e00152fe6
--- /dev/null
+++ b/compiler-rt/lib/hwasan_minimal/hwasan.cpp
@@ -0,0 +1,106 @@
+//===-- hwasan.cpp --------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file is a part of HWAddressSanitizer.
+//
+// HWAddressSanitizer runtime.
+//===----------------------------------------------------------------------===//
+
+#include "hwasan.h"
+#include "hwasan_checks.h"
+#include "hwasan_poisoning.h"
+
+// ACHTUNG! No system header includes in this file.
+
+using namespace __sanitizer;
+
+using namespace __hwasan;
+
+struct hwasan_global {
+  s32 gv_relptr;
+  u32 info;
+};
+
+static void InitGlobals(const hwasan_global *begin, const hwasan_global *end) {
+  for (auto *desc = begin; desc != end; ++desc) {
+    uptr gv = reinterpret_cast<uptr>(desc) + desc->gv_relptr;
+    uptr size = desc->info & 0xffffff;
+    uptr full_granule_size = RoundDownTo(size, 16);
+    u8 tag = desc->info >> 24;
+    TagMemoryAligned(gv, full_granule_size, tag);
+    if (size % 16)
+      TagMemoryAligned(gv + full_granule_size, 16, size % 16);
+  }
+}
+
+// Interface.
+
+void __hwasan_init_static() {
+  // The instrumentation generates these symbols
+  // (see HWAddressSanitizer::instrumentGlobals).
+  extern const hwasan_global __attribute__((weak)) __start_hwasan_globals;
+  extern const hwasan_global __attribute__((weak)) __stop_hwasan_globals;
+  InitGlobals(&__start_hwasan_globals, &__stop_hwasan_globals);
+}
+
+void __hwasan_init() { }
+
+uptr __hwasan_loadN(uptr p, uptr sz) {
+  return CheckAddressSized<ErrorAction::Abort, AccessType::Load>(p, sz);
+}
+uptr __hwasan_load1(uptr p) {
+  return CheckAddress<ErrorAction::Abort, AccessType::Load, 0>(p);
+}
+uptr __hwasan_load2(uptr p) {
+  return CheckAddress<ErrorAction::Abort, AccessType::Load, 1>(p);
+}
+uptr __hwasan_load4(uptr p) {
+  return CheckAddress<ErrorAction::Abort, AccessType::Load, 2>(p);
+}
+uptr __hwasan_load8(uptr p) {
+  return CheckAddress<ErrorAction::Abort, AccessType::Load, 3>(p);
+}
+uptr __hwasan_load16(uptr p) {
+  return CheckAddress<ErrorAction::Abort, AccessType::Load, 4>(p);
+}
+
+uptr __hwasan_storeN(uptr p, uptr sz) {
+  return CheckAddressSized<ErrorAction::Abort, AccessType::Store>(p, sz);
+}
+uptr __hwasan_store1(uptr p) {
+  return CheckAddress<ErrorAction::Abort, AccessType::Store, 0>(p);
+}
+uptr __hwasan_store2(uptr p) {
+  return CheckAddress<ErrorAction::Abort, AccessType::Store, 1>(p);
+}
+uptr __hwasan_store4(uptr p) {
+  return CheckAddress<ErrorAction::Abort, AccessType::Store, 2>(p);
+}
+uptr __hwasan_store8(uptr p) {
+  return CheckAddress<ErrorAction::Abort, AccessType::Store, 3>(p);
+}
+uptr __hwasan_store16(uptr p) {
+  return CheckAddress<ErrorAction::Abort, AccessType::Store, 4>(p);
+}
+
+void __hwasan_tag_memory(uptr p, u8 tag, uptr sz) {
+  TagMemoryAligned(p, sz, tag);
+}
+
+u8 __hwasan_generate_tag() {
+  static u8 tag = 0;
+  // Skip tag 0 in order to avoid collisions with untagged memory.
+  if (tag == 0) {
+    tag = 1;
+  }
+  // Skip tags reserved for Dauntless peripherals.
+  if (tag == 0x40 || tag == 0xe0) {
+    tag++;
+  }
+  return tag++;
+}
diff --git a/compiler-rt/lib/hwasan_minimal/hwasan.h b/compiler-rt/lib/hwasan_minimal/hwasan.h
new file mode 100644
index 000000000000..c1e9acf9e747
--- /dev/null
+++ b/compiler-rt/lib/hwasan_minimal/hwasan.h
@@ -0,0 +1,53 @@
+//===-- hwasan.h ------------------------------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file is a part of HWAddressSanitizer.
+//
+// Private Hwasan header.
+//===----------------------------------------------------------------------===//
+
+#ifndef HWASAN_H
+#define HWASAN_H
+
+#include "sanitizer_common/sanitizer_internal_defs.h"
+#include "hwasan_interface_internal.h"
+
+typedef u8 tag_t;
+
+const unsigned kAddressTagShift = 24;
+const uptr kAddressTagMask = 0xFFUL << kAddressTagShift;
+
+static inline tag_t GetTagFromPointer(uptr p) {
+  return p >> kAddressTagShift;
+}
+
+static inline uptr UntagAddr(uptr tagged_addr) {
+  tag_t ptr_tag = GetTagFromPointer(tagged_addr);
+  // Skip tags reserved for Dauntless peripherals.
+  if (ptr_tag == 0x40 || ptr_tag == 0xe0) {
+    return tagged_addr;
+  }
+  return tagged_addr & ~kAddressTagMask;
+}
+
+static inline void *UntagPtr(const void *tagged_ptr) {
+  return reinterpret_cast<void *>(
+      UntagAddr(reinterpret_cast<uptr>(tagged_ptr)));
+}
+
+static inline uptr AddTagToPointer(uptr p, tag_t tag) {
+  return (p & ~kAddressTagMask) | ((uptr)tag << kAddressTagShift);
+}
+
+namespace __hwasan {
+
+extern int hwasan_inited;
+
+}  // namespace __hwasan
+
+#endif  // HWASAN_H
diff --git a/compiler-rt/lib/hwasan_minimal/hwasan_checks.h b/compiler-rt/lib/hwasan_minimal/hwasan_checks.h
new file mode 100644
index 000000000000..a6be77b136c0
--- /dev/null
+++ b/compiler-rt/lib/hwasan_minimal/hwasan_checks.h
@@ -0,0 +1,148 @@
+//===-- hwasan_checks.h -----------------------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file is a part of HWAddressSanitizer.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef HWASAN_CHECKS_H
+#define HWASAN_CHECKS_H
+
+#include "hwasan_mapping.h"
+#include "sanitizer_common/sanitizer_common.h"
+
+namespace __hwasan {
+template <unsigned X>
+__attribute__((always_inline)) static void SigTrap(uptr p) {
+#if defined(__aarch64__)
+  (void)p;
+  // 0x900 is added to do not interfere with the kernel use of lower values of
+  // brk immediate.
+  register uptr x0 asm("x0") = p;
+  asm("brk %1\n\t" ::"r"(x0), "n"(0x900 + X));
+#elif defined(__x86_64__)
+  // INT3 + NOP DWORD ptr [EAX + X] to pass X to our signal handler, 5 bytes
+  // total. The pointer is passed via rdi.
+  // 0x40 is added as a safeguard, to help distinguish our trap from others and
+  // to avoid 0 offsets in the command (otherwise it'll be reduced to a
+  // different nop command, the three bytes one).
+  asm volatile(
+      "int3\n"
+      "nopl %c0(%%rax)\n" ::"n"(0x40 + X),
+      "D"(p));
+#elif defined(__riscv)
+  (void)p;
+  __builtin_debugtrap();
+#else
+  // FIXME: not always sigill.
+  __builtin_trap();
+#endif
+  // __builtin_unreachable();
+}
+
+// Version with access size which is not power of 2
+template <unsigned X>
+__attribute__((always_inline)) static void SigTrap(uptr p, uptr size) {
+#if defined(__aarch64__)
+  register uptr x0 asm("x0") = p;
+  register uptr x1 asm("x1") = size;
+  asm("brk %2\n\t" ::"r"(x0), "r"(x1), "n"(0x900 + X));
+#elif defined(__x86_64__)
+  // Size is stored in rsi.
+  asm volatile(
+      "int3\n"
+      "nopl %c0(%%rax)\n" ::"n"(0x40 + X),
+      "D"(p), "S"(size));
+#elif defined(__riscv)
+  (void)p;
+  (void)size;
+  __builtin_debugtrap();
+#else
+  __builtin_trap();
+#endif
+  // __builtin_unreachable();
+}
+
+__attribute__((always_inline, nodebug)) static bool PossiblyShortTagMatches(
+    tag_t mem_tag, uptr ptr, uptr sz) {
+  tag_t ptr_tag = GetTagFromPointer(ptr);
+  if (ptr_tag == mem_tag)
+    return true;
+  if (mem_tag >= kShadowAlignment)
+    return false;
+  if ((ptr & (kShadowAlignment - 1)) + sz > mem_tag)
+    return false;
+#ifndef __aarch64__
+  ptr = UntagAddr(ptr);
+#endif
+  return *(u8 *)(ptr | (kShadowAlignment - 1)) == ptr_tag;
+}
+
+enum class ErrorAction { Abort, Recover };
+enum class AccessType { Load, Store };
+
+template <ErrorAction EA, AccessType AT, unsigned LogSize>
+__attribute__((always_inline, nodebug)) static uptr CheckAddress(uptr p) {
+  tag_t ptr_tag = GetTagFromPointer(p);
+  // Skip tags reserved for Dauntless peripherals.
+  if (ptr_tag == 0x40 || ptr_tag == 0xe0) {
+    return p;
+  }
+  uptr ptr_raw = p & ~kAddressTagMask;
+  if (!HasShadow(ptr_raw)) {
+    return ptr_raw;
+  }
+  tag_t mem_tag = *(tag_t *)MemToShadow(ptr_raw);
+  if (UNLIKELY(!PossiblyShortTagMatches(mem_tag, p, 1 << LogSize))) {
+    SigTrap<0x20 * (EA == ErrorAction::Recover) +
+            0x10 * (AT == AccessType::Store) + LogSize>(p);
+    if (EA == ErrorAction::Abort)
+      __builtin_unreachable();
+  }
+  return ptr_raw;
+}
+
+template <ErrorAction EA, AccessType AT>
+__attribute__((always_inline, nodebug)) static uptr CheckAddressSized(uptr p,
+                                                                      uptr sz) {
+  tag_t ptr_tag = GetTagFromPointer(p);
+  // Skip tags reserved for Dauntless peripherals.
+  if (ptr_tag == 0x40 || ptr_tag == 0xe0) {
+    return p;
+  }
+  uptr ptr_raw = p & ~kAddressTagMask;
+  if (sz == 0)
+    return ptr_raw;
+  if (!HasShadow(ptr_raw)) {
+    return ptr_raw;
+  }
+  tag_t *shadow_first = (tag_t *)MemToShadow(ptr_raw);
+  tag_t *shadow_last = (tag_t *)MemToShadow(ptr_raw + sz);
+  for (tag_t *t = shadow_first; t < shadow_last; ++t)
+    if (UNLIKELY(ptr_tag != *t)) {
+      SigTrap<0x20 * (EA == ErrorAction::Recover) +
+              0x10 * (AT == AccessType::Store) + 0xf>(p, sz);
+      if (EA == ErrorAction::Abort)
+        __builtin_unreachable();
+    }
+  uptr end = p + sz;
+  uptr tail_sz = end & 0xf;
+  if (UNLIKELY(tail_sz != 0 &&
+               !PossiblyShortTagMatches(
+                   *shadow_last, end & ~(kShadowAlignment - 1), tail_sz))) {
+    SigTrap<0x20 * (EA == ErrorAction::Recover) +
+            0x10 * (AT == AccessType::Store) + 0xf>(p, sz);
+    if (EA == ErrorAction::Abort)
+      __builtin_unreachable();
+  }
+  return ptr_raw;
+}
+
+}  // end namespace __hwasan
+
+#endif  // HWASAN_CHECKS_H
diff --git a/compiler-rt/lib/hwasan_minimal/hwasan_interface_internal.h b/compiler-rt/lib/hwasan_minimal/hwasan_interface_internal.h
new file mode 100644
index 000000000000..f5906f49e5d7
--- /dev/null
+++ b/compiler-rt/lib/hwasan_minimal/hwasan_interface_internal.h
@@ -0,0 +1,77 @@
+//===-- hwasan_interface_internal.h -----------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file is a part of HWAddressSanitizer.
+//
+// Private Hwasan interface header.
+//===----------------------------------------------------------------------===//
+
+#ifndef HWASAN_INTERFACE_INTERNAL_H
+#define HWASAN_INTERFACE_INTERNAL_H
+
+#include "sanitizer_common/sanitizer_internal_defs.h"
+
+extern "C" {
+
+SANITIZER_INTERFACE_ATTRIBUTE
+void __hwasan_init_static();
+
+SANITIZER_INTERFACE_ATTRIBUTE
+void __hwasan_init();
+
+using __sanitizer::uptr;
+using __sanitizer::u8;
+
+SANITIZER_INTERFACE_ATTRIBUTE
+extern uptr __hwasan_start;
+SANITIZER_INTERFACE_ATTRIBUTE
+extern uptr __hwasan_stop;
+SANITIZER_INTERFACE_ATTRIBUTE
+extern uptr __hwasan_shadow;
+
+SANITIZER_INTERFACE_ATTRIBUTE
+uptr __hwasan_loadN(uptr, uptr);
+SANITIZER_INTERFACE_ATTRIBUTE
+uptr __hwasan_load1(uptr);
+SANITIZER_INTERFACE_ATTRIBUTE
+uptr __hwasan_load2(uptr);
+SANITIZER_INTERFACE_ATTRIBUTE
+uptr __hwasan_load4(uptr);
+SANITIZER_INTERFACE_ATTRIBUTE
+uptr __hwasan_load8(uptr);
+SANITIZER_INTERFACE_ATTRIBUTE
+uptr __hwasan_load16(uptr);
+
+SANITIZER_INTERFACE_ATTRIBUTE
+uptr __hwasan_storeN(uptr, uptr);
+SANITIZER_INTERFACE_ATTRIBUTE
+uptr __hwasan_store1(uptr);
+SANITIZER_INTERFACE_ATTRIBUTE
+uptr __hwasan_store2(uptr);
+SANITIZER_INTERFACE_ATTRIBUTE
+uptr __hwasan_store4(uptr);
+SANITIZER_INTERFACE_ATTRIBUTE
+uptr __hwasan_store8(uptr);
+SANITIZER_INTERFACE_ATTRIBUTE
+uptr __hwasan_store16(uptr);
+
+SANITIZER_INTERFACE_ATTRIBUTE
+void __hwasan_tag_memory(uptr p, u8 tag, uptr sz);
+
+SANITIZER_INTERFACE_ATTRIBUTE
+u8 __hwasan_generate_tag();
+
+SANITIZER_INTERFACE_ATTRIBUTE
+void *__hwasan_memcpy(void *dst, const void *src, uptr size);
+SANITIZER_INTERFACE_ATTRIBUTE
+void *__hwasan_memset(void *s, int c, uptr n);
+SANITIZER_INTERFACE_ATTRIBUTE
+void *__hwasan_memmove(void *dest, const void *src, uptr n);
+}  // extern "C"
+
+#endif  // HWASAN_INTERFACE_INTERNAL_H
diff --git a/compiler-rt/lib/hwasan_minimal/hwasan_macro_redefinitions.h b/compiler-rt/lib/hwasan_minimal/hwasan_macro_redefinitions.h
new file mode 100644
index 000000000000..693d97be1b35
--- /dev/null
+++ b/compiler-rt/lib/hwasan_minimal/hwasan_macro_redefinitions.h
@@ -0,0 +1,21 @@
+//===-- hwasan_macro_redefinitions.h ------------------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file is a part of HWAddressSanitizer.
+//
+//===----------------------------------------------------------------------===//
+
+#undef CHECK_IMPL
+#define CHECK_IMPL(c1, op, c2) \
+  do { \
+    __sanitizer::u64 v1 = (__sanitizer::u64)(c1); \
+    __sanitizer::u64 v2 = (__sanitizer::u64)(c2); \
+    if (UNLIKELY(!(v1 op v2))) \
+      __builtin_debugtrap(); \
+  } while (false) \
+/**/
diff --git a/compiler-rt/lib/hwasan_minimal/hwasan_mapping.h b/compiler-rt/lib/hwasan_minimal/hwasan_mapping.h
new file mode 100644
index 000000000000..fdc884acc405
--- /dev/null
+++ b/compiler-rt/lib/hwasan_minimal/hwasan_mapping.h
@@ -0,0 +1,56 @@
+//===-- hwasan_mapping.h ----------------------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+///
+/// \file
+/// This file is a part of HWAddressSanitizer and defines memory mapping.
+///
+//===----------------------------------------------------------------------===//
+
+#ifndef HWASAN_MAPPING_H
+#define HWASAN_MAPPING_H
+
+#include "sanitizer_common/sanitizer_internal_defs.h"
+#include "hwasan_interface_internal.h"
+
+// Typical mapping on Linux/x86_64:
+// with dynamic shadow mapped at [0x770d59f40000, 0x7f0d59f40000]:
+// || [0x7f0d59f40000, 0x7fffffffffff] || HighMem    ||
+// || [0x7efe2f934000, 0x7f0d59f3ffff] || HighShadow ||
+// || [0x7e7e2f934000, 0x7efe2f933fff] || ShadowGap  ||
+// || [0x770d59f40000, 0x7e7e2f933fff] || LowShadow  ||
+// || [0x000000000000, 0x770d59f3ffff] || LowMem     ||
+
+// Typical mapping on Android/AArch64
+// with dynamic shadow mapped: [0x007477480000, 0x007c77480000]:
+// || [0x007c77480000, 0x007fffffffff] || HighMem    ||
+// || [0x007c3ebc8000, 0x007c7747ffff] || HighShadow ||
+// || [0x007bbebc8000, 0x007c3ebc7fff] || ShadowGap  ||
+// || [0x007477480000, 0x007bbebc7fff] || LowShadow  ||
+// || [0x000000000000, 0x00747747ffff] || LowMem     ||
+
+// Reasonable values are 4 (for 1/16th shadow) and 6 (for 1/64th).
+constexpr uptr kShadowScale = 4;
+constexpr uptr kShadowAlignment = 1ULL << kShadowScale;
+
+namespace __hwasan {
+
+inline uptr MemToShadow(uptr untagged_addr) {
+  return ((untagged_addr - (uptr)(&__hwasan_start)) >> kShadowScale) +
+         (uptr)(&__hwasan_shadow);
+}
+inline uptr MemToShadowSize(uptr size) {
+  return size >> kShadowScale;
+}
+inline bool HasShadow(uptr untagged_addr) {
+  return untagged_addr >= (uptr)(&__hwasan_start) &&
+         untagged_addr < (uptr)(&__hwasan_stop);
+}
+
+}  // namespace __hwasan
+
+#endif  // HWASAN_MAPPING_H
diff --git a/compiler-rt/lib/hwasan_minimal/hwasan_memintrinsics.cpp b/compiler-rt/lib/hwasan_minimal/hwasan_memintrinsics.cpp
new file mode 100644
index 000000000000..15fe5cc53cd0
--- /dev/null
+++ b/compiler-rt/lib/hwasan_minimal/hwasan_memintrinsics.cpp
@@ -0,0 +1,42 @@
+//===-- hwasan_memintrinsics.cpp --------------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+///
+/// \file
+/// This file is a part of HWAddressSanitizer and contains HWASAN versions of
+/// memset, memcpy and memmove
+///
+//===----------------------------------------------------------------------===//
+
+#include <string.h>
+#include "hwasan.h"
+#include "hwasan_checks.h"
+#include "hwasan_interface_internal.h"
+
+using namespace __hwasan;
+
+void *__hwasan_memset(void *block, int c, uptr size) {
+  CheckAddressSized<ErrorAction::Recover, AccessType::Store>(
+      reinterpret_cast<uptr>(block), size);
+  return memset(UntagPtr(block), c, size);
+}
+
+void *__hwasan_memcpy(void *to, const void *from, uptr size) {
+  CheckAddressSized<ErrorAction::Recover, AccessType::Store>(
+      reinterpret_cast<uptr>(to), size);
+  CheckAddressSized<ErrorAction::Recover, AccessType::Load>(
+      reinterpret_cast<uptr>(from), size);
+  return memcpy(UntagPtr(to), UntagPtr(from), size);
+}
+
+void *__hwasan_memmove(void *to, const void *from, uptr size) {
+  CheckAddressSized<ErrorAction::Recover, AccessType::Store>(
+      reinterpret_cast<uptr>(to), size);
+  CheckAddressSized<ErrorAction::Recover, AccessType::Load>(
+      reinterpret_cast<uptr>(from), size);
+  return memmove(UntagPtr(to), UntagPtr(from), size);
+}
diff --git a/compiler-rt/lib/hwasan_minimal/hwasan_poisoning.cpp b/compiler-rt/lib/hwasan_minimal/hwasan_poisoning.cpp
new file mode 100644
index 000000000000..37f4b02e686e
--- /dev/null
+++ b/compiler-rt/lib/hwasan_minimal/hwasan_poisoning.cpp
@@ -0,0 +1,39 @@
+//===-- hwasan_poisoning.cpp ------------------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file is a part of HWAddressSanitizer.
+//
+//===----------------------------------------------------------------------===//
+
+#include "hwasan_poisoning.h"
+
+#include "hwasan_mapping.h"
+#include "sanitizer_common/sanitizer_common.h"
+#include "hwasan_macro_redefinitions.h"
+
+namespace __hwasan {
+
+uptr TagMemoryAligned(uptr p, uptr size, tag_t tag) {
+  if (!HasShadow(p)) {
+    return p;
+  }
+  CHECK(IsAligned(p, kShadowAlignment));
+  CHECK(IsAligned(size, kShadowAlignment));
+  uptr shadow_start = MemToShadow(p);
+  uptr shadow_size = MemToShadowSize(size);
+  internal_memset((void *)shadow_start, tag, shadow_size);
+  return AddTagToPointer(p, tag);
+}
+
+uptr TagMemory(uptr p, uptr size, tag_t tag) {
+  uptr start = RoundDownTo(p, kShadowAlignment);
+  uptr end = RoundUpTo(p + size, kShadowAlignment);
+  return TagMemoryAligned(start, end - start, tag);
+}
+
+}  // namespace __hwasan
diff --git a/compiler-rt/lib/hwasan_minimal/hwasan_poisoning.h b/compiler-rt/lib/hwasan_minimal/hwasan_poisoning.h
new file mode 100644
index 000000000000..61751f7d252e
--- /dev/null
+++ b/compiler-rt/lib/hwasan_minimal/hwasan_poisoning.h
@@ -0,0 +1,24 @@
+//===-- hwasan_poisoning.h --------------------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file is a part of HWAddressSanitizer.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef HWASAN_POISONING_H
+#define HWASAN_POISONING_H
+
+#include "hwasan.h"
+
+namespace __hwasan {
+uptr TagMemory(uptr p, uptr size, tag_t tag);
+uptr TagMemoryAligned(uptr p, uptr size, tag_t tag);
+
+}  // namespace __hwasan
+
+#endif  // HWASAN_POISONING_H
diff --git a/compiler-rt/lib/hwasan_minimal/sanitizer_libc.cpp b/compiler-rt/lib/hwasan_minimal/sanitizer_libc.cpp
new file mode 100644
index 000000000000..d436a43afa4c
--- /dev/null
+++ b/compiler-rt/lib/hwasan_minimal/sanitizer_libc.cpp
@@ -0,0 +1,41 @@
+//===-- sanitizer_libc.cpp ------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file is shared between AddressSanitizer and ThreadSanitizer
+// run-time libraries. See sanitizer_libc.h for details.
+//===----------------------------------------------------------------------===//
+
+#include "sanitizer_common/sanitizer_common.h"
+
+namespace __sanitizer {
+
+void *internal_memset(void* s, int c, uptr n) {
+  // Optimize for the most performance-critical case:
+  if ((reinterpret_cast<uptr>(s) % 16) == 0 && (n % 16) == 0) {
+    u64 *p = reinterpret_cast<u64*>(s);
+    u64 *e = p + n / 8;
+    u64 v = c;
+    v |= v << 8;
+    v |= v << 16;
+    v |= v << 32;
+    for (; p < e; p += 2)
+      p[0] = p[1] = v;
+    return s;
+  }
+  // The next line prevents Clang from making a call to memset() instead of the
+  // loop below.
+  // FIXME: building the runtime with -ffreestanding is a better idea. However
+  // there currently are linktime problems due to PR12396.
+  char volatile *t = (char*)s;
+  for (uptr i = 0; i < n; ++i, ++t) {
+    *t = c;
+  }
+  return s;
+}
+
+} // namespace __sanitizer
diff --git a/compiler-rt/lib/sanitizer_common/sanitizer_platform.h b/compiler-rt/lib/sanitizer_common/sanitizer_platform.h
index 32005eef08cd..890e2890d71d 100644
--- a/compiler-rt/lib/sanitizer_common/sanitizer_platform.h
+++ b/compiler-rt/lib/sanitizer_common/sanitizer_platform.h
@@ -14,7 +14,8 @@
 
 #if !defined(__linux__) && !defined(__FreeBSD__) && !defined(__NetBSD__) && \
     !defined(__APPLE__) && !defined(_WIN32) && !defined(__Fuchsia__) &&     \
-    !(defined(__sun__) && defined(__svr4__))
+    !(defined(__sun__) && defined(__svr4__)) && \
+    !(defined(__riscv) && __riscv_xlen == 32)
 #  error "This operating system is not supported"
 #endif
 
diff --git a/llvm/include/llvm/BinaryFormat/ELF.h b/llvm/include/llvm/BinaryFormat/ELF.h
index 99e7a9868c29..585f52bfd638 100644
--- a/llvm/include/llvm/BinaryFormat/ELF.h
+++ b/llvm/include/llvm/BinaryFormat/ELF.h
@@ -668,6 +668,7 @@ enum : unsigned {
   EF_RISCV_FLOAT_ABI_QUAD = 0x0006,
   EF_RISCV_RVE = 0x0008,
   EF_RISCV_TSO = 0x0010,
+  EF_RISCV_SOTERIA = 0x0020
 };
 
 // ELF Relocation types for RISC-V
diff --git a/llvm/include/llvm/IR/IntrinsicsRISCV.td b/llvm/include/llvm/IR/IntrinsicsRISCV.td
index 098ca1bc6cfb..9ca43fb6a980 100644
--- a/llvm/include/llvm/IR/IntrinsicsRISCV.td
+++ b/llvm/include/llvm/IR/IntrinsicsRISCV.td
@@ -598,7 +598,7 @@ let TargetPrefix = "riscv" in {
   class RISCVClassifyMasked
         : Intrinsic<[LLVMVectorOfBitcastsToInt<0>],
                     [LLVMVectorOfBitcastsToInt<0>, llvm_anyvector_ty,
-                     LLVMScalarOrSameVectorWidth<0, llvm_i1_ty>, 
+                     LLVMScalarOrSameVectorWidth<0, llvm_i1_ty>,
                      llvm_anyint_ty, LLVMMatchType<1>],
                     [IntrNoMem, ImmArg<ArgIndex<4>>]>, RISCVVIntrinsic {
     let VLOperand = 3;
@@ -1610,3 +1610,25 @@ def int_riscv_sm4ed      : ScalarCryptoByteSelectAny;
 def int_riscv_sm3p0      : ScalarCryptoGprIntrinsicAny;
 def int_riscv_sm3p1      : ScalarCryptoGprIntrinsicAny;
 } // TargetPrefix = "riscv"
+
+//===----------------------------------------------------------------------===//
+// Soteria
+
+let TargetPrefix = "riscv" in {
+class SoteriaIntrinsic<list<LLVMType> ret_types = [],
+                       list<LLVMType> param_types = [],
+                       list<IntrinsicProperty> properties = []>
+  : Intrinsic<ret_types, param_types, properties>;
+
+def int_riscv_soteria_grev
+  : SoteriaIntrinsic<[llvm_i32_ty], [llvm_i32_ty, llvm_i32_ty],
+                     [IntrNoMem]>;
+def int_riscv_soteria_bitc
+  : SoteriaIntrinsic<[llvm_i32_ty], [llvm_i32_ty, llvm_i32_ty],
+                     [IntrNoMem]>;
+def int_riscv_soteria_bits
+  : SoteriaIntrinsic<[llvm_i32_ty], [llvm_i32_ty, llvm_i32_ty],
+                     [IntrNoMem]>;
+def int_riscv_soteria_fls
+  : SoteriaIntrinsic<[llvm_i32_ty], [llvm_i32_ty], [IntrNoMem]>;
+} // TargetPrefix = "riscv"
diff --git a/llvm/include/llvm/Support/RISCVTargetParser.def b/llvm/include/llvm/Support/RISCVTargetParser.def
index f658cdb91c6b..b909687494c4 100644
--- a/llvm/include/llvm/Support/RISCVTargetParser.def
+++ b/llvm/include/llvm/Support/RISCVTargetParser.def
@@ -16,6 +16,7 @@ PROC(INVALID, {"invalid"}, FK_INVALID, {""})
 PROC(GENERIC_RV32, {"generic-rv32"}, FK_NONE, {""})
 PROC(GENERIC_RV64, {"generic-rv64"}, FK_64BIT, {""})
 PROC(ROCKET_RV32, {"rocket-rv32"}, FK_NONE, {""})
+PROC(SOTERIA, {"soteria"}, FK_NONE, {"rv32imcxsoteria"})
 PROC(ROCKET_RV64, {"rocket-rv64"}, FK_64BIT, {""})
 PROC(SIFIVE_732, {"sifive-7-rv32"}, FK_NONE, {""})
 PROC(SIFIVE_764, {"sifive-7-rv64"}, FK_64BIT, {""})
diff --git a/llvm/lib/Object/ELFObjectFile.cpp b/llvm/lib/Object/ELFObjectFile.cpp
index 1f342e55e77f..f1270077703d 100644
--- a/llvm/lib/Object/ELFObjectFile.cpp
+++ b/llvm/lib/Object/ELFObjectFile.cpp
@@ -292,6 +292,9 @@ SubtargetFeatures ELFObjectFileBase::getRISCVFeatures() const {
   if (PlatformFlags & ELF::EF_RISCV_RVC) {
     Features.AddFeature("c");
   }
+  if (PlatformFlags & ELF::EF_RISCV_SOTERIA) {
+    Features.AddFeature("xsoteria");
+  }
 
   // Add features according to the ELF attribute section.
   // If there are any unrecognized features, ignore them.
diff --git a/llvm/lib/Support/RISCVISAInfo.cpp b/llvm/lib/Support/RISCVISAInfo.cpp
index 0fe286d239d4..eb0c6984d13a 100644
--- a/llvm/lib/Support/RISCVISAInfo.cpp
+++ b/llvm/lib/Support/RISCVISAInfo.cpp
@@ -101,6 +101,7 @@ static const RISCVSupportedExtension SupportedExtensions[] = {
     {"zicbom", RISCVExtensionVersion{1, 0}},
     {"zicboz", RISCVExtensionVersion{1, 0}},
     {"zicbop", RISCVExtensionVersion{1, 0}},
+    {"xsoteria", RISCVExtensionVersion{1, 0}},
 };
 
 static const RISCVSupportedExtension SupportedExperimentalExtensions[] = {
diff --git a/llvm/lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.cpp b/llvm/lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.cpp
index c5f8a42bab6a..1ed505a4d6a6 100644
--- a/llvm/lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.cpp
+++ b/llvm/lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.cpp
@@ -157,6 +157,8 @@ void RISCVTargetELFStreamer::finish() {
 
   if (Features[RISCV::FeatureStdExtC])
     EFlags |= ELF::EF_RISCV_RVC;
+  if (Features[RISCV::FeatureSoteria])
+    EFlags |= ELF::EF_RISCV_SOTERIA;
 
   switch (ABI) {
   case RISCVABI::ABI_ILP32:
diff --git a/llvm/lib/Target/RISCV/RISCV.td b/llvm/lib/Target/RISCV/RISCV.td
index 8a6f69c7f7ca..7b6c677878b6 100644
--- a/llvm/lib/Target/RISCV/RISCV.td
+++ b/llvm/lib/Target/RISCV/RISCV.td
@@ -443,6 +443,13 @@ def IsRV32 : Predicate<"!Subtarget->is64Bit()">,
                        AssemblerPredicate<(all_of (not Feature64Bit)),
                        "RV32I Base Instruction Set">;
 
+def FeatureSoteria
+    : SubtargetFeature<"xsoteria", "HasExtSoteria", "true",
+                       "'Soteria' (Soteria non-standard instructions)">;
+def HasExtSoteria : Predicate<"Subtarget->hasExtSoteria()">,
+                               AssemblerPredicate<(all_of FeatureSoteria),
+                        "'xsoteria' Soteria extensions">;
+
 defvar RV32 = DefaultMode;
 def RV64           : HwMode<"+64bit">;
 
@@ -497,6 +504,7 @@ include "RISCVCallingConv.td"
 include "RISCVInstrInfo.td"
 include "RISCVRegisterBanks.td"
 include "RISCVSchedRocket.td"
+include "RISCVSchedSoteria.td"
 include "RISCVSchedSiFive7.td"
 
 //===----------------------------------------------------------------------===//
@@ -509,6 +517,10 @@ def : ProcessorModel<"generic-rv64", NoSchedModel, [Feature64Bit]>;
 // to change to the appropriate rv32/rv64 version.
 def : ProcessorModel<"generic", NoSchedModel, []>;
 
+def : ProcessorModel<"soteria", SoteriaModel, [FeatureStdExtM,
+                                               FeatureStdExtC,
+                                               FeatureSoteria]>;
+
 def : ProcessorModel<"rocket-rv32", RocketModel, []>;
 def : ProcessorModel<"rocket-rv64", RocketModel, [Feature64Bit]>;
 
diff --git a/llvm/lib/Target/RISCV/RISCVISelLowering.cpp b/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
index d0ca325e9c14..65a43ac9e11c 100644
--- a/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
+++ b/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
@@ -283,8 +283,12 @@ RISCVTargetLowering::RISCVTargetLowering(const TargetMachine &TM,
           {ISD::CTTZ, ISD::CTTZ_ZERO_UNDEF, ISD::CTLZ, ISD::CTLZ_ZERO_UNDEF},
           MVT::i32, Custom);
   } else {
-    setOperationAction({ISD::CTTZ, ISD::CTLZ, ISD::CTPOP}, XLenVT, Expand);
-
+    if (Subtarget.hasExtSoteria()) {
+      setOperationAction({ISD::CTLZ, ISD::CTPOP}, XLenVT, Legal);
+      setOperationAction(ISD::CTTZ, XLenVT, Expand);
+    } else {
+      setOperationAction({ISD::CTTZ, ISD::CTLZ, ISD::CTPOP}, XLenVT, Expand);
+    }
     if (Subtarget.is64Bit())
       setOperationAction(ISD::ABS, MVT::i32, Custom);
   }
diff --git a/llvm/lib/Target/RISCV/RISCVInstrInfo.td b/llvm/lib/Target/RISCV/RISCVInstrInfo.td
index 78fd09fbf387..303b6715aa10 100644
--- a/llvm/lib/Target/RISCV/RISCVInstrInfo.td
+++ b/llvm/lib/Target/RISCV/RISCVInstrInfo.td
@@ -1686,3 +1686,4 @@ include "RISCVInstrInfoZk.td"
 include "RISCVInstrInfoV.td"
 include "RISCVInstrInfoZfh.td"
 include "RISCVInstrInfoZicbo.td"
+include "RISCVInstrInfoSoteria.td"
diff --git a/llvm/lib/Target/RISCV/RISCVInstrInfoSoteria.td b/llvm/lib/Target/RISCV/RISCVInstrInfoSoteria.td
new file mode 100644
index 000000000000..18c1f1ceca89
--- /dev/null
+++ b/llvm/lib/Target/RISCV/RISCVInstrInfoSoteria.td
@@ -0,0 +1,104 @@
+//===-- RISCVInstrInfoSoteria.td - Soteria instructions ----*- tablegen -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file describes the RISC-V instructions that are specific to the
+// Soteria architecture.
+//
+//===----------------------------------------------------------------------===//
+
+
+def OPC_GREV  : RISCVOpcode<"GREV", 0b0101011>;
+def OPC_GREVI : RISCVOpcode<"GREVI", 0b0001011>;
+def OPC_BITC  : RISCVOpcode<"BITC", 0b0101011>;
+def OPC_BITCI : RISCVOpcode<"BITCI", 0b0001011>;
+def OPC_BITS  : RISCVOpcode<"BITS", 0b0101011>;
+def OPC_BITSI : RISCVOpcode<"BITSI", 0b0001011>;
+def OPC_PCNT  : RISCVOpcode<"PCNT", 0b0001011>;
+def OPC_CLZ   : RISCVOpcode<"CLZ", 0b0001011>;
+def OPC_FLS   : RISCVOpcode<"FLS", 0b0001011>;
+
+// Some Soteria specific instructions take 2 register operands with a normal R
+// style encoding.
+let mayLoad = 0, mayStore = 0, hasSideEffects = 0 in {
+class SoteriaInstR<bits<7> funct7, bits<3> funct3, RISCVOpcode opcode, string opcodestr>
+  : RVInstR<funct7, funct3, opcode, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2), opcodestr, "$rd, $rs1, $rs2">;
+
+// Other soteria instructions take a single register operand and a 5 bit
+// immediate value.
+class SoteriaInstI<bits<7> funct7, bits<3> funct3, RISCVOpcode opcode, string opcodestr>
+  : RVInst<(outs GPR:$rd), (ins GPR:$rs1, uimm5:$imm5), opcodestr, "$rd, $rs1, $imm5", [], InstFormatOther> {
+  bits<5> rs1;
+  bits<5> imm5;
+  bits<5> rd;
+
+  let Inst{31-25} = funct7;
+  let Inst{24-20} = imm5;
+  let Inst{19-15} = rs1;
+  let Inst{14-12} = funct3;
+  let Inst{11-7} = rd;
+  let Opcode = opcode.Value;
+}
+
+// PCNT, CLZ and FLS instructions only have a single source operand.
+class SoteriaInst<bits<12> funct12, bits<3> funct3, RISCVOpcode opcode, string opcodestr>
+  : RVInst<(outs GPR:$rd), (ins GPR:$rs1), opcodestr, "$rd, $rs1", [], InstFormatOther> {
+  bits<5> rs1;
+  bits<5> rd;
+
+  let Inst{31-20} = funct12;
+  let Inst{19-15} = rs1;
+  let Inst{14-12} = funct3;
+  let Inst{11-7} = rd;
+  let Opcode = opcode.Value;
+}
+}
+
+let Predicates = [HasExtSoteria] in {
+def SOT_GREV  : SoteriaInstR<0b0000000, 0b000, OPC_GREV, "grev">,
+                Sched<[WriteIALU, ReadIALU, ReadIALU]>;
+def SOT_GREVI : SoteriaInstI<0b0000000, 0b000, OPC_GREVI, "grevi">,
+                Sched<[WriteIALU, ReadIALU]>;
+def SOT_BITC  : SoteriaInstR<0b0000000, 0b001, OPC_BITC, "bitc">,
+                Sched<[WriteIALU, ReadIALU, ReadIALU]>;
+def SOT_BITCI : SoteriaInstI<0b0000000, 0b001, OPC_BITCI, "bitci">,
+                Sched<[WriteIALU, ReadIALU]>;
+def SOT_BITS  : SoteriaInstR<0b0100000, 0b001, OPC_BITS, "bits">,
+                Sched<[WriteIALU, ReadIALU, ReadIALU]>;
+def SOT_BITSI : SoteriaInstI<0b0100000, 0b001, OPC_BITSI, "bitsi">,
+                Sched<[WriteIALU, ReadIALU]>;
+def SOT_PCNT  : SoteriaInst<0b000000000000, 0b011, OPC_PCNT, "pcnt">,
+                Sched<[WriteIALU, ReadIALU]>;
+def SOT_CLZ   : SoteriaInst<0b010000000000, 0b010, OPC_CLZ, "clz">,
+                Sched<[WriteIALU, ReadIALU]>;
+def SOT_FLS   : SoteriaInst<0b000000000000, 0b010, OPC_FLS, "fls">,
+                Sched<[WriteIALU, ReadIALU]>;
+}
+
+let Predicates = [HasExtSoteria] in {
+def : Pat<(int_riscv_soteria_grev GPR:$rs1, GPR:$rs2),
+          (SOT_GREV GPR:$rs1, GPR:$rs2)>;
+def : Pat<(int_riscv_soteria_grev GPR:$rs1, uimm5:$imm5),
+          (SOT_GREVI GPR:$rs1, uimm5:$imm5)>;
+def : Pat<(int_riscv_soteria_bitc GPR:$rs1, GPR:$rs2),
+          (SOT_BITC GPR:$rs1, GPR:$rs2)>;
+def : Pat<(int_riscv_soteria_bitc GPR:$rs1, uimm5:$imm5),
+          (SOT_BITCI GPR:$rs1, uimm5:$imm5)>;
+def : Pat<(int_riscv_soteria_bits GPR:$rs1, GPR:$rs2),
+          (SOT_BITS GPR:$rs1, GPR:$rs2)>;
+def : Pat<(int_riscv_soteria_bits GPR:$rs1, uimm5:$imm5),
+          (SOT_BITSI GPR:$rs1, uimm5:$imm5)>;
+// TODO: add cttz, bswap
+def : Pat<(ctpop GPR:$rs1), (SOT_PCNT GPR:$rs1)>;
+def : Pat<(ctlz GPR:$rs1), (SOT_CLZ GPR:$rs1)>;
+def : Pat<(int_riscv_soteria_fls GPR:$rs1), (SOT_FLS GPR:$rs1)>;
+
+def : Pat<(and (xor (shl 1, GPR:$rs2), -1), GPR:$rs1),
+          (SOT_BITC GPR:$rs1, GPR:$rs2)>;
+def : Pat<(or (shl 1, GPR:$rs2), GPR:$rs1),
+          (SOT_BITS GPR:$rs1, GPR:$rs2)>;
+}
diff --git a/llvm/lib/Target/RISCV/RISCVSchedSoteria.td b/llvm/lib/Target/RISCV/RISCVSchedSoteria.td
new file mode 100644
index 000000000000..1cf646749c54
--- /dev/null
+++ b/llvm/lib/Target/RISCV/RISCVSchedSoteria.td
@@ -0,0 +1,211 @@
+// ===---------------------------------------------------------------------===//
+// The following definitions describe the simpler per-operand machine model.
+// This works with MachineScheduler. See MCSchedule.h for details.
+
+// Soteria machine model for scheduling and other instruction cost heuristics.
+def SoteriaModel : SchedMachineModel {
+  let MicroOpBufferSize = 1; // Soteria is in-order.
+  let IssueWidth = 1;        // 1 micro-op is dispatched per cycle.
+  let LoadLatency = 3;
+  let HighLatency = 4;
+  let MispredictPenalty = 0;
+  let CompleteModel = false;
+  let UnsupportedFeatures = [HasStdExtA, HasStdExtF, HasStdExtD,
+                             HasStdExtZbkb, HasStdExtZbkc, HasStdExtZbkx,
+                             HasStdExtZknd, HasStdExtZkne, HasStdExtZknh,
+                             HasStdExtZksed, HasStdExtZksh, HasStdExtZkr,
+                             HasVInstructions, HasVInstructionsI64];
+}
+
+//===----------------------------------------------------------------------===//
+// Define each kind of processor resource and number available.
+
+// Modeling each pipeline as a ProcResource using the BufferSize = 0 since
+// Soteria is in-order.
+let BufferSize = 0 in {
+  def SoteriaUnitALU        : ProcResource<1>; // Int ALU / Branch
+  def SoteriaUnitMem        : ProcResource<1>; // Memory
+  def SoteriaUnitMul        : ProcResource<1>; // Multiply
+  def SoteriaUnitDiv        : ProcResource<1>; // Division
+  def SoteriaUnitB          : ProcResource<1>; // Branches
+}
+
+//===----------------------------------------------------------------------===//
+
+let SchedModel = SoteriaModel in {
+
+// Branching
+let Latency = 4, ResourceCycles = [4] in {
+  def : WriteRes<WriteJmp, [SoteriaUnitB]>;
+  def : WriteRes<WriteJal, [SoteriaUnitB]>;
+  def : WriteRes<WriteJalr, [SoteriaUnitB]>;
+  def : WriteRes<WriteJmpReg, [SoteriaUnitB]>;
+}
+
+// Integer arithmetic and logic
+let Latency = 1 in {
+  def : WriteRes<WriteIALU32, [SoteriaUnitALU]>;
+  def : WriteRes<WriteIALU, [SoteriaUnitALU]>;
+  def : WriteRes<WriteShiftImm32, [SoteriaUnitALU]>;
+  def : WriteRes<WriteShiftImm, [SoteriaUnitALU]>;
+  def : WriteRes<WriteShiftReg32, [SoteriaUnitALU]>;
+  def : WriteRes<WriteShiftReg, [SoteriaUnitALU]>;
+}
+
+// Integer multiplication
+let Latency = 3, ResourceCycles = [2] in {
+  def : WriteRes<WriteIMul, [SoteriaUnitMul]>;  
+  def : WriteRes<WriteIMul32, [SoteriaUnitMul]>;
+}
+
+// Integer division, constant latency
+let Latency = 32, ResourceCycles = [31] in {
+  def : WriteRes<WriteIDiv32, [SoteriaUnitDiv]>;
+  def : WriteRes<WriteIDiv, [SoteriaUnitDiv]>;
+}
+
+// Memory
+let Latency = 3, ResourceCycles = [2] in {
+  def : WriteRes<WriteSTB, [SoteriaUnitMem]>;
+  def : WriteRes<WriteSTH, [SoteriaUnitMem]>;
+  def : WriteRes<WriteSTW, [SoteriaUnitMem]>;
+  def : WriteRes<WriteSTD, [SoteriaUnitMem]>;
+}
+
+let Latency = 3, ResourceCycles = [2] in {
+  def : WriteRes<WriteLDB, [SoteriaUnitMem]>;
+  def : WriteRes<WriteLDH, [SoteriaUnitMem]>;
+  def : WriteRes<WriteLDW, [SoteriaUnitMem]>;
+  def : WriteRes<WriteLDWU, [SoteriaUnitMem]>;
+  def : WriteRes<WriteLDD, [SoteriaUnitMem]>;
+}
+
+// Atomics & FP are not supported, but definitons are required
+let Latency = 128 in {
+  def : WriteRes<WriteFLD32, [SoteriaUnitMem]>;
+  def : WriteRes<WriteFLD64, [SoteriaUnitMem]>;
+  def : WriteRes<WriteFST32, [SoteriaUnitMem]>;
+  def : WriteRes<WriteFST64, [SoteriaUnitMem]>;
+  def : WriteRes<WriteFALU32, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFSGNJ32, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFMinMax32, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFALU64, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFSGNJ64, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFMinMax64, [SoteriaUnitALU]>;
+
+  def : WriteRes<WriteFCvtI32ToF32, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFCvtI32ToF64, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFCvtI64ToF32, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFCvtI64ToF64, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFCvtF32ToI32, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFCvtF32ToI64, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFCvtF64ToI32, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFCvtF64ToI64, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFCvtF32ToF64, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFCvtF64ToF32, [SoteriaUnitALU]>;
+
+  def : WriteRes<WriteFClass32, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFClass64, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFCmp32, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFCmp64, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFMovF32ToI32, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFMovI32ToF32, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFMovF64ToI64, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFMovI64ToF64, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFMul32, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFMA32, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFMul64, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFMA64, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFDiv32, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFDiv64, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFSqrt32, [SoteriaUnitALU]>;
+  def : WriteRes<WriteFSqrt64, [SoteriaUnitALU]>;
+
+  def : WriteRes<WriteAtomicW, [SoteriaUnitMem]>;
+  def : WriteRes<WriteAtomicD, [SoteriaUnitMem]>;
+  def : WriteRes<WriteAtomicLDW, [SoteriaUnitMem]>;
+  def : WriteRes<WriteAtomicLDD, [SoteriaUnitMem]>;
+  def : WriteRes<WriteAtomicSTW, [SoteriaUnitMem]>;
+  def : WriteRes<WriteAtomicSTD, [SoteriaUnitMem]>;
+}
+
+// Others
+def : WriteRes<WriteCSR, [SoteriaUnitALU]> { let Latency = 2; }
+def : WriteRes<WriteNop, [SoteriaUnitALU]> { let Latency = 1; }
+
+def : InstRW<[WriteIALU], (instrs COPY)>;
+
+//===----------------------------------------------------------------------===//
+// Bypass and advance
+def : ReadAdvance<ReadJmp, 0>;
+def : ReadAdvance<ReadJalr, 0>;
+def : ReadAdvance<ReadCSR, 0>;
+def : ReadAdvance<ReadStoreData, 0>;
+def : ReadAdvance<ReadMemBase, -1>;
+def : ReadAdvance<ReadIALU, 0>;
+def : ReadAdvance<ReadIALU32, 0>;
+def : ReadAdvance<ReadShiftImm, 0>;
+def : ReadAdvance<ReadShiftImm32, 0>;
+def : ReadAdvance<ReadShiftReg, 0>;
+def : ReadAdvance<ReadShiftReg32, 0>;
+def : ReadAdvance<ReadIDiv, 0>;
+def : ReadAdvance<ReadIDiv32, 0>;
+def : ReadAdvance<ReadIMul, 0>;
+def : ReadAdvance<ReadIMul32, 0>;
+def : ReadAdvance<ReadAtomicWA, 0>;
+def : ReadAdvance<ReadAtomicWD, 0>;
+def : ReadAdvance<ReadAtomicDA, 0>;
+def : ReadAdvance<ReadAtomicDD, 0>;
+def : ReadAdvance<ReadAtomicLDW, 0>;
+def : ReadAdvance<ReadAtomicLDD, 0>;
+def : ReadAdvance<ReadAtomicSTW, 0>;
+def : ReadAdvance<ReadAtomicSTD, 0>;
+def : ReadAdvance<ReadFMemBase, 0>;
+def : ReadAdvance<ReadFALU32, 0>;
+def : ReadAdvance<ReadFALU64, 0>;
+def : ReadAdvance<ReadFMul32, 0>;
+def : ReadAdvance<ReadFMA32, 0>;
+def : ReadAdvance<ReadFMul64, 0>;
+def : ReadAdvance<ReadFMA64, 0>;
+def : ReadAdvance<ReadFDiv32, 0>;
+def : ReadAdvance<ReadFDiv64, 0>;
+def : ReadAdvance<ReadFSqrt32, 0>;
+def : ReadAdvance<ReadFSqrt64, 0>;
+def : ReadAdvance<ReadFCmp32, 0>;
+def : ReadAdvance<ReadFCmp64, 0>;
+def : ReadAdvance<ReadFSGNJ32, 0>;
+def : ReadAdvance<ReadFSGNJ64, 0>;
+def : ReadAdvance<ReadFMinMax32, 0>;
+def : ReadAdvance<ReadFMinMax64, 0>;
+def : ReadAdvance<ReadFCvtF32ToI32, 0>;
+def : ReadAdvance<ReadFCvtF32ToI64, 0>;
+def : ReadAdvance<ReadFCvtF64ToI32, 0>;
+def : ReadAdvance<ReadFCvtF64ToI64, 0>;
+def : ReadAdvance<ReadFCvtI32ToF32, 0>;
+def : ReadAdvance<ReadFCvtI32ToF64, 0>;
+def : ReadAdvance<ReadFCvtI64ToF32, 0>;
+def : ReadAdvance<ReadFCvtI64ToF64, 0>;
+def : ReadAdvance<ReadFCvtF32ToF64, 0>;
+def : ReadAdvance<ReadFCvtF64ToF32, 0>;
+def : ReadAdvance<ReadFMovF32ToI32, 0>;
+def : ReadAdvance<ReadFMovI32ToF32, 0>;
+def : ReadAdvance<ReadFMovF64ToI64, 0>;
+def : ReadAdvance<ReadFMovI64ToF64, 0>;
+def : ReadAdvance<ReadFClass32, 0>;
+def : ReadAdvance<ReadFClass64, 0>;
+
+//===----------------------------------------------------------------------===//
+// Unsupported extensions
+defm : UnsupportedSchedV;
+defm : UnsupportedSchedZba;
+defm : UnsupportedSchedZbb;
+defm : UnsupportedSchedZbc;
+defm : UnsupportedSchedZbs;
+defm : UnsupportedSchedZbe;
+defm : UnsupportedSchedZbf;
+defm : UnsupportedSchedZbm;
+defm : UnsupportedSchedZbp;
+defm : UnsupportedSchedZbr;
+defm : UnsupportedSchedZbt;
+defm : UnsupportedSchedZfh;
+}
diff --git a/llvm/lib/Target/RISCV/RISCVSubtarget.h b/llvm/lib/Target/RISCV/RISCVSubtarget.h
index 6eb949fa551c..c257c32ffeae 100644
--- a/llvm/lib/Target/RISCV/RISCVSubtarget.h
+++ b/llvm/lib/Target/RISCV/RISCVSubtarget.h
@@ -92,6 +92,7 @@ private:
   bool HasStdExtZmmul = false;
   bool HasRV64 = false;
   bool IsRV32E = false;
+  bool HasExtSoteria = false;
   bool EnableLinkerRelax = false;
   bool EnableRVCHintInstrs = true;
   bool EnableDefaultUnroll = true;
@@ -188,6 +189,7 @@ public:
   bool hasStdExtZmmul() const { return HasStdExtZmmul; }
   bool is64Bit() const { return HasRV64; }
   bool isRV32E() const { return IsRV32E; }
+  bool hasExtSoteria() const { return HasExtSoteria; }
   bool enableLinkerRelax() const { return EnableLinkerRelax; }
   bool enableRVCHintInstrs() const { return EnableRVCHintInstrs; }
   bool enableDefaultUnroll() const { return EnableDefaultUnroll; }
diff --git a/llvm/lib/Target/RISCV/RISCVSystemOperands.td b/llvm/lib/Target/RISCV/RISCVSystemOperands.td
index b9aa25b321b0..1ac729b019f2 100644
--- a/llvm/lib/Target/RISCV/RISCVSystemOperands.td
+++ b/llvm/lib/Target/RISCV/RISCVSystemOperands.td
@@ -378,3 +378,5 @@ foreach i = 0...3 in {
 //===-----------------------------------------------
 
 def SEED : SysReg<"seed", 0x015>;
+
+include "SoteriaSystemOperands.td"
\ No newline at end of file
diff --git a/llvm/lib/Target/RISCV/SoteriaSystemOperands.td b/llvm/lib/Target/RISCV/SoteriaSystemOperands.td
new file mode 100644
index 000000000000..9d460c0b4d21
--- /dev/null
+++ b/llvm/lib/Target/RISCV/SoteriaSystemOperands.td
@@ -0,0 +1,51 @@
+//===-----------------------------------------------
+// Soteria Non-Standard CSRs
+//===-----------------------------------------------
+def : SysReg<"mgpscratch0",  0x7C0>;
+def : SysReg<"mgpscratch1",  0x7C1>;
+def : SysReg<"mgpscratch2",  0x7C2>;
+def : SysReg<"mgpscratch3",  0x7C3>;
+def : SysReg<"mgpscratch4",  0x7C4>;
+def : SysReg<"mgpscratch5",  0x7C5>;
+def : SysReg<"mgpscratch6",  0x7C6>;
+def : SysReg<"mgpscratch7",  0x7C7>;
+def : SysReg<"mgpscratch8",  0x7C8>;
+def : SysReg<"mgpscratch9",  0x7C9>;
+def : SysReg<"mgpscratch10", 0x7CA>;
+def : SysReg<"mgpscratch11", 0x7CB>;
+def : SysReg<"mgpscratch12", 0x7CC>;
+def : SysReg<"mgpscratch13", 0x7CD>;
+def : SysReg<"mgpscratch14", 0x7CE>;
+def : SysReg<"mgpscratch15", 0x7CF>;
+def : SysReg<"mnmivec",      0x7D0>;
+def : SysReg<"ualert",       0x802>;
+
+//===-----------------------------------------------
+// Soteria Attack Countermeasure CSRs
+//===-----------------------------------------------
+def : SysReg<"mx0",          0xBC0>;
+
+//===-----------------------------------------------
+// Soteria Control Flow Integrity CSRs
+//===-----------------------------------------------
+def : SysReg<"ucfic",        0x807>;
+def : SysReg<"ucfiseed0",    0x803>;
+def : SysReg<"ucfiseed1",    0x80A>;
+def : SysReg<"ucfichk0",     0x80E>;
+def : SysReg<"ucfichk1",     0x806>;
+def : SysReg<"ucfimix0",     0x805>;
+def : SysReg<"ucfimix1",     0x801>;
+def : SysReg<"ucfisave0",    0x804>;
+def : SysReg<"ucfisave1",    0x80F>;
+
+//===-----------------------------------------------
+// Soteria Pseudorandom Decoy Instruction CSRs
+//===-----------------------------------------------
+def : SysReg<"mpigrate",     0xBC9>;
+def : SysReg<"mpigseed0",    0xBCE>;
+def : SysReg<"mpigseed1",    0xBCC>;
+
+//===-----------------------------------------------
+// Soteria Machine State Wipe
+//===-----------------------------------------------
+def : SysReg<"uswc",         0x800>;
\ No newline at end of file
diff --git a/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp b/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
index b01c74320380..c8b690d2656c 100644
--- a/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
+++ b/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
@@ -547,6 +547,7 @@ void HWAddressSanitizer::initializeModule() {
   auto &DL = M.getDataLayout();
 
   TargetTriple = Triple(M.getTargetTriple());
+  PointerTagShift = TargetTriple.isArch64Bit() ? 56 : 24;
 
   // x86_64 currently has two modes:
   // - Intel LAM (default)
@@ -613,7 +614,7 @@ void HWAddressSanitizer::initializeModule() {
       instrumentPersonalityFunctions();
   }
 
-  if (!TargetTriple.isAndroid()) {
+  if (!TargetTriple.isAndroid() && !TargetTriple.isRISCV()) {
     Constant *C = M.getOrInsertGlobal("__hwasan_tls", IntptrTy, [&] {
       auto *GV = new GlobalVariable(M, IntptrTy, /*isConstant=*/false,
                                     GlobalValue::ExternalLinkage, nullptr,
@@ -631,10 +632,11 @@ void HWAddressSanitizer::initializeCallbacks(Module &M) {
   for (size_t AccessIsWrite = 0; AccessIsWrite <= 1; AccessIsWrite++) {
     const std::string TypeStr = AccessIsWrite ? "store" : "load";
     const std::string EndingStr = Recover ? "_noabort" : "";
+    Type *ReturnType = TargetTriple.isRISCV() ? IntptrTy : IRB.getVoidTy();
 
     HwasanMemoryAccessCallbackSized[AccessIsWrite] = M.getOrInsertFunction(
         ClMemoryAccessCallbackPrefix + TypeStr + "N" + EndingStr,
-        FunctionType::get(IRB.getVoidTy(), {IntptrTy, IntptrTy}, false));
+        FunctionType::get(ReturnType, {IntptrTy, IntptrTy}, false));
 
     for (size_t AccessSizeIndex = 0; AccessSizeIndex < kNumberOfAccessSizes;
          AccessSizeIndex++) {
@@ -642,7 +644,7 @@ void HWAddressSanitizer::initializeCallbacks(Module &M) {
           M.getOrInsertFunction(
               ClMemoryAccessCallbackPrefix + TypeStr +
                   itostr(1ULL << AccessSizeIndex) + EndingStr,
-              FunctionType::get(IRB.getVoidTy(), {IntptrTy}, false));
+              FunctionType::get(ReturnType, {IntptrTy}, false));
     }
   }
 
@@ -791,7 +793,8 @@ static size_t TypeSizeToSizeIndex(uint32_t TypeSize) {
 }
 
 void HWAddressSanitizer::untagPointerOperand(Instruction *I, Value *Addr) {
-  if (TargetTriple.isAArch64() || TargetTriple.getArch() == Triple::x86_64)
+  if (TargetTriple.isAArch64() || TargetTriple.getArch() == Triple::x86_64 ||
+      TargetTriple.isRISCV())
     return;
 
   IRBuilder<> IRB(I);
@@ -909,6 +912,12 @@ void HWAddressSanitizer::instrumentMemAccessInline(Value *Ptr, bool IsWrite,
         "{x0}",
         /*hasSideEffects=*/true);
     break;
+  case Triple::riscv32:
+  case Triple::riscv64:
+    Asm = InlineAsm::get(
+        FunctionType::get(IRB.getVoidTy(), {PtrLong->getType()}, false),
+        "ebreak", "{x0}", /*hasSideEffects=*/true);
+    break;
   default:
     report_fatal_error("unsupported architecture");
   }
@@ -962,15 +971,30 @@ bool HWAddressSanitizer::instrumentMemAccess(InterestingMemoryOperand &O) {
     if (InstrumentWithCalls) {
       IRB.CreateCall(HwasanMemoryAccessCallback[O.IsWrite][AccessSizeIndex],
                      IRB.CreatePointerCast(Addr, IntptrTy));
+      if (TargetTriple.isRISCV()) {
+        Instruction *I = O.getInsn();
+        Value *UntaggedAddr =
+            IRB.CreateCall(HwasanMemoryAccessCallbackSized[O.IsWrite],
+                           {IRB.CreatePointerCast(Addr, IntptrTy),
+                            ConstantInt::get(IntptrTy, O.TypeSize / 8)});
+        Value *UntaggedPtr = IRB.CreateIntToPtr(UntaggedAddr, Addr->getType());
+        I->setOperand(getPointerOperandIndex(I), UntaggedPtr);
+      }
     } else if (OutlinedChecks) {
       instrumentMemAccessOutline(Addr, O.IsWrite, AccessSizeIndex, O.getInsn());
     } else {
       instrumentMemAccessInline(Addr, O.IsWrite, AccessSizeIndex, O.getInsn());
     }
   } else {
-    IRB.CreateCall(HwasanMemoryAccessCallbackSized[O.IsWrite],
-                   {IRB.CreatePointerCast(Addr, IntptrTy),
-                    ConstantInt::get(IntptrTy, O.TypeSize / 8)});
+    Value *UntaggedAddr =
+        IRB.CreateCall(HwasanMemoryAccessCallbackSized[O.IsWrite],
+                       {IRB.CreatePointerCast(Addr, IntptrTy),
+                        ConstantInt::get(IntptrTy, O.TypeSize / 8)});
+    if (TargetTriple.isRISCV()) {
+      Instruction *I = O.getInsn();
+      Value *UntaggedPtr = IRB.CreateIntToPtr(UntaggedAddr, Addr->getType());
+      I->setOperand(getPointerOperandIndex(I), UntaggedPtr);
+    }
   }
   untagPointerOperand(O.getInsn(), Addr);
 
@@ -1617,6 +1641,10 @@ void HWAddressSanitizer::instrumentGlobals() {
     // Skip tag 0 in order to avoid collisions with untagged memory.
     if (Tag == 0)
       Tag = 1;
+    // Skip tags reserved for Dauntless peripherals.
+    if (TargetTriple.isRISCV() && (Tag == 0x40 || Tag == 0xe0)) {
+      Tag++;
+    }
     instrumentGlobal(GV, Tag++);
   }
 }
diff --git a/llvm/test/CodeGen/RISCV/builtins-soteria.ll b/llvm/test/CodeGen/RISCV/builtins-soteria.ll
new file mode 100644
index 000000000000..06974f7706a2
--- /dev/null
+++ b/llvm/test/CodeGen/RISCV/builtins-soteria.ll
@@ -0,0 +1,94 @@
+; RUN: llc -O3 -verify-machineinstrs --show-mc-encoding < %s \
+; RUN: | FileCheck %s -check-prefix=RV32S
+
+target datalayout = "e-m:e-p:32:32-i64:64-n32-S128"
+target triple = "riscv32-unknown-unknown-elf"
+
+define dso_local i32 @grev(i32 %a, i32 %b) local_unnamed_addr #0 {
+; RV32S-LABEL: grev:
+entry:
+  %0 = tail call i32 @llvm.riscv.soteria.grev(i32 %a, i32 %b)
+  ; RV32S: grev a0, a0, a1 # encoding: [0x2b,0x05,0xb5,0x00]
+  ret i32 %0
+}
+
+define dso_local i32 @grevi(i32 %a) local_unnamed_addr #0 {
+; RV32S-LABEL: grevi:
+entry:
+  %0 = tail call i32 @llvm.riscv.soteria.grev(i32 %a, i32 16)
+  ; RV32S: grevi a0, a0, 16 # encoding: [0x0b,0x05,0x05,0x01]
+  ret i32 %0
+}
+
+define dso_local i32 @bitc(i32 %a, i32 %b) local_unnamed_addr #0 {
+; RV32S-LABEL: bitc:
+entry:
+  %0 = tail call i32 @llvm.riscv.soteria.bitc(i32 %a, i32 %b)
+  ; RV32S: bitc a0, a0, a1 # encoding: [0x2b,0x15,0xb5,0x00]
+  ret i32 %0
+}
+
+define dso_local i32 @bitci(i32 %a) local_unnamed_addr #0 {
+; RV32S-LABEL: bitci:
+entry:
+  %0 = tail call i32 @llvm.riscv.soteria.bitc(i32 %a, i32 18)
+  ; RV32S: bitci a0, a0, 18 # encoding: [0x0b,0x15,0x25,0x01]
+  ret i32 %0
+}
+
+define dso_local i32 @bits(i32 %a, i32 %b) local_unnamed_addr #0 {
+; RV32S-LABEL: bits:
+entry:
+  %0 = tail call i32 @llvm.riscv.soteria.bits(i32 %a, i32 %b)
+  ; RV32S: bits a0, a0, a1 # encoding: [0x2b,0x15,0xb5,0x40]
+  ret i32 %0
+}
+
+define dso_local i32 @bitsi(i32 %a) local_unnamed_addr #0 {
+; RV32S-LABEL: bitsi:
+entry:
+  %0 = tail call i32 @llvm.riscv.soteria.bits(i32 %a, i32 31)
+  ; RV32S: bitsi a0, a0, 31 # encoding: [0x0b,0x15,0xf5,0x41]
+  ret i32 %0
+}
+
+define dso_local i32 @pcnt(i32 %a) local_unnamed_addr #0 {
+; RV32S-LABEL: pcnt:
+entry:
+  %0 = tail call i32 @llvm.ctpop.i32(i32 %a), !range !3
+  ; RV32S: pcnt a0, a0 # encoding: [0x0b,0x35,0x05,0x00]
+  ret i32 %0
+}
+
+define dso_local i32 @clz(i32 %a) local_unnamed_addr #0 {
+; RV32S-LABEL: clz:
+entry:
+  %0 = tail call i32 @llvm.ctlz.i32(i32 %a, i1 true), !range !3
+  ; RV32S: clz a0, a0 # encoding: [0x0b,0x25,0x05,0x40]
+  ret i32 %0
+}
+
+define dso_local i32 @fls(i32 %a) local_unnamed_addr #0 {
+; RV32S-LABEL: fls:
+entry:
+  %0 = tail call i32 @llvm.riscv.soteria.fls(i32 %a)
+  ; RV32S: fls a0, a0 # encoding: [0x0b,0x25,0x05,0x00]
+  ret i32 %0
+}
+
+declare i32 @llvm.riscv.soteria.grev(i32, i32) #1
+declare i32 @llvm.riscv.soteria.bitc(i32, i32) #1
+declare i32 @llvm.riscv.soteria.bits(i32, i32) #1
+declare i32 @llvm.ctpop.i32(i32) #1
+declare i32 @llvm.ctlz.i32(i32, i1 immarg) #1
+declare i32 @llvm.riscv.soteria.fls(i32) #1
+
+attributes #0 = { nounwind readnone "target-features"="+c,+m,+relax,+xsoteria" }
+attributes #1 = { nounwind readnone }
+
+!llvm.module.flags = !{!0, !1}
+
+!0 = !{i32 1, !"wchar_size", i32 4}
+!1 = !{i32 1, !"target-abi", !"ilp32"}
+!3 = !{i32 0, i32 33}
+
diff --git a/llvm/test/Instrumentation/HWAddressSanitizer/RISCV/rv32i.ll b/llvm/test/Instrumentation/HWAddressSanitizer/RISCV/rv32i.ll
new file mode 100644
index 000000000000..769959fd33c6
--- /dev/null
+++ b/llvm/test/Instrumentation/HWAddressSanitizer/RISCV/rv32i.ll
@@ -0,0 +1,27 @@
+; RUN: opt < %s -S -hwasan \
+; RUN:   -hwasan-record-stack-history=0 \
+; RUN:   -hwasan-globals=1 \
+; RUN:   -hwasan-instrument-with-calls=1 \
+; RUN:   | FileCheck %s
+
+target datalayout = "e-m:e-p:32:32-i64:64-n32-S128"
+target triple = "riscv32-unknown-unknown-elf"
+
+@g = global i32 1
+; CHECK: @g = alias i32, inttoptr (i64 add (i64 ptrtoint ({ i32, [12 x i8] }* @g.hwasan to i64), i64 [[TAG:[0-9]+]]) to i32*)
+
+define void @test(i32* %a, i32 %b) sanitize_hwaddress {
+; CHECK-LABEL: @test(
+
+; Validate that the runtime function is invoked to check and untag the pointer.
+; CHECK: %[[A:[^ ]*]] = ptrtoint i32* %a to i32
+; CHECK: %[[UNTAGGED:[^ ]*]] = call i32 @__hwasan_store4(i32 %[[A]])
+; CHECK: %[[UNTAGGED_PTR:[^ ]*]] = inttoptr i32 %[[UNTAGGED]] to i32*
+; CHECK: store i32 %b, i32* %[[UNTAGGED_PTR]], align 4
+; CHECK: ret void
+
+entry:
+  store i32 %b, i32* %a, align 4
+  ret void
+}
+
diff --git a/llvm/test/MC/RISCV/soteria-csr-names.s b/llvm/test/MC/RISCV/soteria-csr-names.s
new file mode 100644
index 000000000000..8574bc01cff1
--- /dev/null
+++ b/llvm/test/MC/RISCV/soteria-csr-names.s
@@ -0,0 +1,488 @@
+# RUN: llvm-mc %s -triple=riscv32 -riscv-no-aliases -show-encoding \
+# RUN:     | FileCheck -check-prefixes=CHECK-INST,CHECK-ENC %s
+# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
+# RUN:     | llvm-objdump -d - \
+# RUN:     | FileCheck -check-prefix=CHECK-INST-ALIAS %s
+
+###################################################
+# Soteria Non-Standard CSRs
+###################################################
+
+# mgpscratch0
+# name
+# CHECK-INST: csrrs t1, mgpscratch0, zero
+# CHECK-ENC: encoding: [0x73,0x23,0x00,0x7c]
+# CHECK-INST-ALIAS: csrr t1, mgpscratch0
+# uimm12
+# CHECK-INST: csrrs t2, mgpscratch0, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0x00,0x7c]
+# CHECK-INST-ALIAS: csrr t2, mgpscratch0
+# name
+csrrs t1, mgpscratch0, zero
+# uimm12
+csrrs t2, 0x7C0, zero
+
+# mgpscratch1
+# name
+# CHECK-INST: csrrs t1, mgpscratch1, zero
+# CHECK-ENC: encoding: [0x73,0x23,0x10,0x7c]
+# CHECK-INST-ALIAS: csrr t1, mgpscratch1
+# uimm12
+# CHECK-INST: csrrs t2, mgpscratch1, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0x10,0x7c]
+# CHECK-INST-ALIAS: csrr t2, mgpscratch1
+# name
+csrrs t1, mgpscratch1, zero
+# uimm12
+csrrs t2, 0x7C1, zero
+
+# mgpscratch2
+# name
+# CHECK-INST: csrrs t1, mgpscratch2, zero
+# CHECK-ENC: encoding: [0x73,0x23,0x20,0x7c]
+# CHECK-INST-ALIAS: csrr t1, mgpscratch2
+# uimm12
+# CHECK-INST: csrrs t2, mgpscratch2, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0x20,0x7c]
+# CHECK-INST-ALIAS: csrr t2, mgpscratch2
+# name
+csrrs t1, mgpscratch2, zero
+# uimm12
+csrrs t2, 0x7C2, zero
+
+# mgpscratch3
+# name
+# CHECK-INST: csrrs t1, mgpscratch3, zero
+# CHECK-ENC: encoding: [0x73,0x23,0x30,0x7c]
+# CHECK-INST-ALIAS: csrr t1, mgpscratch3
+# uimm12
+# CHECK-INST: csrrs t2, mgpscratch3, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0x30,0x7c]
+# CHECK-INST-ALIAS: csrr t2, mgpscratch3
+# name
+csrrs t1, mgpscratch3, zero
+# uimm12
+csrrs t2, 0x7C3, zero
+
+# mgpscratch4
+# name
+# CHECK-INST: csrrs t1, mgpscratch4, zero
+# CHECK-ENC: encoding: [0x73,0x23,0x40,0x7c]
+# CHECK-INST-ALIAS: csrr t1, mgpscratch4
+# uimm12
+# CHECK-INST: csrrs t2, mgpscratch4, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0x40,0x7c]
+# CHECK-INST-ALIAS: csrr t2, mgpscratch4
+# name
+csrrs t1, mgpscratch4, zero
+# uimm12
+csrrs t2, 0x7C4, zero
+
+# mgpscratch5
+# name
+# CHECK-INST: csrrs t1, mgpscratch5, zero
+# CHECK-ENC: encoding: [0x73,0x23,0x50,0x7c]
+# CHECK-INST-ALIAS: csrr t1, mgpscratch5
+# uimm12
+# CHECK-INST: csrrs t2, mgpscratch5, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0x50,0x7c]
+# CHECK-INST-ALIAS: csrr t2, mgpscratch5
+# name
+csrrs t1, mgpscratch5, zero
+# uimm12
+csrrs t2, 0x7C5, zero
+
+# mgpscratch6
+# name
+# CHECK-INST: csrrs t1, mgpscratch6, zero
+# CHECK-ENC: encoding: [0x73,0x23,0x60,0x7c]
+# CHECK-INST-ALIAS: csrr t1, mgpscratch6
+# uimm12
+# CHECK-INST: csrrs t2, mgpscratch6, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0x60,0x7c]
+# CHECK-INST-ALIAS: csrr t2, mgpscratch6
+# name
+csrrs t1, mgpscratch6, zero
+# uimm12
+csrrs t2, 0x7C6, zero
+
+# mgpscratch7
+# name
+# CHECK-INST: csrrs t1, mgpscratch7, zero
+# CHECK-ENC: encoding: [0x73,0x23,0x70,0x7c]
+# CHECK-INST-ALIAS: csrr t1, mgpscratch7
+# uimm12
+# CHECK-INST: csrrs t2, mgpscratch7, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0x70,0x7c]
+# CHECK-INST-ALIAS: csrr t2, mgpscratch7
+# name
+csrrs t1, mgpscratch7, zero
+# uimm12
+csrrs t2, 0x7C7, zero
+
+# mgpscratch8
+# name
+# CHECK-INST: csrrs t1, mgpscratch8, zero
+# CHECK-ENC: encoding: [0x73,0x23,0x80,0x7c]
+# CHECK-INST-ALIAS: csrr t1, mgpscratch8
+# uimm12
+# CHECK-INST: csrrs t2, mgpscratch8, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0x80,0x7c]
+# CHECK-INST-ALIAS: csrr t2, mgpscratch8
+# name
+csrrs t1, mgpscratch8, zero
+# uimm12
+csrrs t2, 0x7C8, zero
+
+# mgpscratch9
+# name
+# CHECK-INST: csrrs t1, mgpscratch9, zero
+# CHECK-ENC: encoding: [0x73,0x23,0x90,0x7c]
+# CHECK-INST-ALIAS: csrr t1, mgpscratch9
+# uimm12
+# CHECK-INST: csrrs t2, mgpscratch9, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0x90,0x7c]
+# CHECK-INST-ALIAS: csrr t2, mgpscratch9
+# name
+csrrs t1, mgpscratch9, zero
+# uimm12
+csrrs t2, 0x7C9, zero
+
+# mgpscratch10
+# name
+# CHECK-INST: csrrs t1, mgpscratch10, zero
+# CHECK-ENC: encoding: [0x73,0x23,0xa0,0x7c]
+# CHECK-INST-ALIAS: csrr t1, mgpscratch10
+# uimm12
+# CHECK-INST: csrrs t2, mgpscratch10, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0xa0,0x7c]
+# CHECK-INST-ALIAS: csrr t2, mgpscratch10
+# name
+csrrs t1, mgpscratch10, zero
+# uimm12
+csrrs t2, 0x7CA, zero
+
+# mgpscratch11
+# name
+# CHECK-INST: csrrs t1, mgpscratch11, zero
+# CHECK-ENC: encoding: [0x73,0x23,0xb0,0x7c]
+# CHECK-INST-ALIAS: csrr t1, mgpscratch11
+# uimm12
+# CHECK-INST: csrrs t2, mgpscratch11, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0xb0,0x7c]
+# CHECK-INST-ALIAS: csrr t2, mgpscratch11
+# name
+csrrs t1, mgpscratch11, zero
+# uimm12
+csrrs t2, 0x7CB, zero
+
+# mgpscratch12
+# name
+# CHECK-INST: csrrs t1, mgpscratch12, zero
+# CHECK-ENC: encoding: [0x73,0x23,0xc0,0x7c]
+# CHECK-INST-ALIAS: csrr t1, mgpscratch12
+# uimm12
+# CHECK-INST: csrrs t2, mgpscratch12, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0xc0,0x7c]
+# CHECK-INST-ALIAS: csrr t2, mgpscratch12
+# name
+csrrs t1, mgpscratch12, zero
+# uimm12
+csrrs t2, 0x7CC, zero
+
+# mgpscratch13
+# name
+# CHECK-INST: csrrs t1, mgpscratch13, zero
+# CHECK-ENC: encoding: [0x73,0x23,0xd0,0x7c]
+# CHECK-INST-ALIAS: csrr t1, mgpscratch13
+# uimm12
+# CHECK-INST: csrrs t2, mgpscratch13, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0xd0,0x7c]
+# CHECK-INST-ALIAS: csrr t2, mgpscratch13
+# name
+csrrs t1, mgpscratch13, zero
+# uimm12
+csrrs t2, 0x7CD, zero
+
+# mgpscratch14
+# name
+# CHECK-INST: csrrs t1, mgpscratch14, zero
+# CHECK-ENC: encoding: [0x73,0x23,0xe0,0x7c]
+# CHECK-INST-ALIAS: csrr t1, mgpscratch14
+# uimm12
+# CHECK-INST: csrrs t2, mgpscratch14, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0xe0,0x7c]
+# CHECK-INST-ALIAS: csrr t2, mgpscratch14
+# name
+csrrs t1, mgpscratch14, zero
+# uimm12
+csrrs t2, 0x7CE, zero
+
+# mgpscratch15
+# name
+# CHECK-INST: csrrs t1, mgpscratch15, zero
+# CHECK-ENC: encoding: [0x73,0x23,0xf0,0x7c]
+# CHECK-INST-ALIAS: csrr t1, mgpscratch15
+# uimm12
+# CHECK-INST: csrrs t2, mgpscratch15, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0xf0,0x7c]
+# CHECK-INST-ALIAS: csrr t2, mgpscratch15
+# name
+csrrs t1, mgpscratch15, zero
+# uimm12
+csrrs t2, 0x7CF, zero
+
+# mnmivec
+# name
+# CHECK-INST: csrrs t1, mnmivec, zero
+# CHECK-ENC: encoding: [0x73,0x23,0x00,0x7d]
+# CHECK-INST-ALIAS: csrr t1, mnmivec
+# uimm12
+# CHECK-INST: csrrs t2, mnmivec, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0x00,0x7d]
+# CHECK-INST-ALIAS: csrr t2, mnmivec
+# name
+csrrs t1, mnmivec, zero
+# uimm12
+csrrs t2, 0x7D0, zero
+
+# ualert
+# name
+# CHECK-INST: csrrs t1, ualert, zero
+# CHECK-ENC: encoding: [0x73,0x23,0x20,0x80]
+# CHECK-INST-ALIAS: csrr t1, ualert
+# uimm12
+# CHECK-INST: csrrs t2, ualert, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0x20,0x80]
+# CHECK-INST-ALIAS: csrr t2, ualert
+# name
+csrrs t1, ualert, zero
+# uimm12
+csrrs t2, 0x802, zero
+
+
+###################################################
+# Soteria Attack Countermeasure CSRs
+###################################################
+
+# mx0
+# name
+# CHECK-INST: csrrs t1, mx0, zero
+# CHECK-ENC: encoding: [0x73,0x23,0x00,0xbc]
+# CHECK-INST-ALIAS: csrr t1, mx0
+# uimm12
+# CHECK-INST: csrrs t2, mx0, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0x00,0xbc]
+# CHECK-INST-ALIAS: csrr t2, mx0
+# name
+csrrs t1, mx0, zero
+# uimm12
+csrrs t2, 0xBC0, zero
+
+###################################################
+# Soteria Control Flow Integrity CSRs
+###################################################
+
+# ucfic
+# name
+# CHECK-INST: csrrs t1, ucfic, zero
+# CHECK-ENC: encoding: [0x73,0x23,0x70,0x80]
+# CHECK-INST-ALIAS: csrr t1, ucfic
+# uimm12
+# CHECK-INST: csrrs t2, ucfic, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0x70,0x80]
+# CHECK-INST-ALIAS: csrr t2, ucfic
+# name
+csrrs t1, ucfic, zero
+# uimm12
+csrrs t2, 0x807, zero
+
+# ucfiseed0
+# name
+# CHECK-INST: csrrs t1, ucfiseed0, zero
+# CHECK-ENC: encoding: [0x73,0x23,0x30,0x80]
+# CHECK-INST-ALIAS: csrr t1, ucfiseed0
+# uimm12
+# CHECK-INST: csrrs t2, ucfiseed0, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0x30,0x80]
+# CHECK-INST-ALIAS: csrr t2, ucfiseed0
+# name
+csrrs t1, ucfiseed0, zero
+# uimm12
+csrrs t2, 0x803, zero
+
+# ucfiseed1
+# name
+# CHECK-INST: csrrs t1, ucfiseed1, zero
+# CHECK-ENC: encoding: [0x73,0x23,0xa0,0x80]
+# CHECK-INST-ALIAS: csrr t1, ucfiseed1
+# uimm12
+# CHECK-INST: csrrs t2, ucfiseed1, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0xa0,0x80]
+# CHECK-INST-ALIAS: csrr t2, ucfiseed1
+# name
+csrrs t1, ucfiseed1, zero
+# uimm12
+csrrs t2, 0x80A, zero
+
+# ucfichk0
+# name
+# CHECK-INST: csrrs t1, ucfichk0, zero
+# CHECK-ENC: encoding: [0x73,0x23,0xe0,0x80]
+# CHECK-INST-ALIAS: csrr t1, ucfichk0
+# uimm12
+# CHECK-INST: csrrs t2, ucfichk0, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0xe0,0x80]
+# CHECK-INST-ALIAS: csrr t2, ucfichk0
+# name
+csrrs t1, ucfichk0, zero
+# uimm12
+csrrs t2, 0x80E, zero
+
+# ucfichk1
+# name
+# CHECK-INST: csrrs t1, ucfichk1, zero
+# CHECK-ENC: encoding: [0x73,0x23,0x60,0x80]
+# CHECK-INST-ALIAS: csrr t1, ucfichk1
+# uimm12
+# CHECK-INST: csrrs t2, ucfichk1, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0x60,0x80]
+# CHECK-INST-ALIAS: csrr t2, ucfichk1
+# name
+csrrs t1, ucfichk1, zero
+# uimm12
+csrrs t2, 0x806, zero
+
+# ucfimix0
+# name
+# CHECK-INST: csrrs t1, ucfimix0, zero
+# CHECK-ENC: encoding: [0x73,0x23,0x50,0x80]
+# CHECK-INST-ALIAS: csrr t1, ucfimix0
+# uimm12
+# CHECK-INST: csrrs t2, ucfimix0, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0x50,0x80]
+# CHECK-INST-ALIAS: csrr t2, ucfimix0
+# name
+csrrs t1, ucfimix0, zero
+# uimm12
+csrrs t2, 0x805, zero
+
+# ucfimix1
+# name
+# CHECK-INST: csrrs t1, ucfimix1, zero
+# CHECK-ENC: encoding: [0x73,0x23,0x10,0x80]
+# CHECK-INST-ALIAS: csrr t1, ucfimix1
+# uimm12
+# CHECK-INST: csrrs t2, ucfimix1, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0x10,0x80]
+# CHECK-INST-ALIAS: csrr t2, ucfimix1
+# name
+csrrs t1, ucfimix1, zero
+# uimm12
+csrrs t2, 0x801, zero
+
+# ucfisave0
+# name
+# CHECK-INST: csrrs t1, ucfisave0, zero
+# CHECK-ENC: encoding: [0x73,0x23,0x40,0x80]
+# CHECK-INST-ALIAS: csrr t1, ucfisave0
+# uimm12
+# CHECK-INST: csrrs t2, ucfisave0, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0x40,0x80]
+# CHECK-INST-ALIAS: csrr t2, ucfisave0
+# name
+csrrs t1, ucfisave0, zero
+# uimm12
+csrrs t2, 0x804, zero
+
+# ucfisave0
+# name
+# CHECK-INST: csrrs t1, ucfisave0, zero
+# CHECK-ENC: encoding: [0x73,0x23,0x40,0x80]
+# CHECK-INST-ALIAS: csrr t1, ucfisave0
+# uimm12
+# CHECK-INST: csrrs t2, ucfisave0, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0x40,0x80]
+# CHECK-INST-ALIAS: csrr t2, ucfisave0
+# name
+csrrs t1, ucfisave0, zero
+# uimm12
+csrrs t2, 0x804, zero
+
+# ucfisave1
+# name
+# CHECK-INST: csrrs t1, ucfisave1, zero
+# CHECK-ENC: encoding: [0x73,0x23,0xf0,0x80]
+# CHECK-INST-ALIAS: csrr t1, ucfisave1
+# uimm12
+# CHECK-INST: csrrs t2, ucfisave1, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0xf0,0x80]
+# CHECK-INST-ALIAS: csrr t2, ucfisave1
+# name
+csrrs t1, ucfisave1, zero
+# uimm12
+csrrs t2, 0x80F, zero
+
+###################################################
+# Soteria Pseudorandom Decoy Instruction CSRs
+###################################################
+
+# mpigrate
+# name
+# CHECK-INST: csrrs t1, mpigrate, zero
+# CHECK-ENC: encoding: [0x73,0x23,0x90,0xbc]
+# CHECK-INST-ALIAS: csrr t1, mpigrate
+# uimm12
+# CHECK-INST: csrrs t2, mpigrate, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0x90,0xbc]
+# CHECK-INST-ALIAS: csrr t2, mpigrate
+# name
+csrrs t1, mpigrate, zero
+# uimm12
+csrrs t2, 0xBC9, zero
+
+# mpigseed0
+# name
+# CHECK-INST: csrrs t1, mpigseed0, zero
+# CHECK-ENC: encoding: [0x73,0x23,0xe0,0xbc]
+# CHECK-INST-ALIAS: csrr t1, mpigseed0
+# uimm12
+# CHECK-INST: csrrs t2, mpigseed0, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0xe0,0xbc]
+# CHECK-INST-ALIAS: csrr t2, mpigseed0
+# name
+csrrs t1, mpigseed0, zero
+# uimm12
+csrrs t2, 0xBCE, zero
+
+# mpigseed1
+# name
+# CHECK-INST: csrrs t1, mpigseed1, zero
+# CHECK-ENC: encoding: [0x73,0x23,0xc0,0xbc]
+# CHECK-INST-ALIAS: csrr t1, mpigseed1
+# uimm12
+# CHECK-INST: csrrs t2, mpigseed1, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0xc0,0xbc]
+# CHECK-INST-ALIAS: csrr t2, mpigseed1
+# name
+csrrs t1, mpigseed1, zero
+# uimm12
+csrrs t2, 0xBCC, zero
+
+###################################################
+# Soteria Machine State Wipe
+###################################################
+
+# uswc
+# name
+# CHECK-INST: csrrs t1, uswc, zero
+# CHECK-ENC: encoding: [0x73,0x23,0x00,0x80]
+# CHECK-INST-ALIAS: csrr t1, uswc
+# uimm12
+# CHECK-INST: csrrs t2, uswc, zero
+# CHECK-ENC: encoding: [0xf3,0x23,0x00,0x80]
+# CHECK-INST-ALIAS: csrr t2, uswc
+# name
+csrrs t1, uswc, zero
+# uimm12
+csrrs t2, 0x800, zero
diff --git a/llvm/tools/llvm-readobj/ELFDumper.cpp b/llvm/tools/llvm-readobj/ELFDumper.cpp
index ba7bae96ade3..587b32e11c7b 100644
--- a/llvm/tools/llvm-readobj/ELFDumper.cpp
+++ b/llvm/tools/llvm-readobj/ELFDumper.cpp
@@ -1624,6 +1624,7 @@ const EnumEntry<unsigned> ElfHeaderRISCVFlags[] = {
   ENUM_ENT(EF_RISCV_FLOAT_ABI_QUAD, "quad-float ABI"),
   ENUM_ENT(EF_RISCV_RVE, "RVE"),
   ENUM_ENT(EF_RISCV_TSO, "TSO"),
+  ENUM_ENT(EF_RISCV_SOTERIA, "Soteria")
 };
 
 const EnumEntry<unsigned> ElfHeaderAVRFlags[] = {
