diff --git a/clvk/src/api.cpp b/clvk/src/api.cpp
index c86fe36..8f02e6e 100644
--- a/clvk/src/api.cpp
+++ b/clvk/src/api.cpp
@@ -3956,13 +3956,6 @@ cl_mem cvk_create_image(cl_context context, cl_mem_flags flags,
         return nullptr;
     }
 
-    if ((flags & (CL_MEM_USE_HOST_PTR | CL_MEM_COPY_HOST_PTR)) ||
-        (host_ptr != nullptr)) {
-        cvk_error("Creating an image with a host_ptr is not supported yet");
-        *errcode_ret = CL_INVALID_OPERATION;
-        return nullptr;
-    }
-
     auto image =
         cvk_image::create(icd_downcast(context), flags, image_desc,
                           image_format, host_ptr, std::move(properties));
diff --git a/clvk/src/memory.cpp b/clvk/src/memory.cpp
index 9f95b39..5c4a194 100644
--- a/clvk/src/memory.cpp
+++ b/clvk/src/memory.cpp
@@ -15,6 +15,7 @@
 #include <cmath>
 
 #include "memory.hpp"
+#include "queue.hpp"
 
 bool cvk_mem::map() {
     std::lock_guard<std::mutex> lock(m_map_lock);
@@ -253,39 +254,60 @@ bool cvk_image::init() {
     // Translate image type and size
     VkImageType image_type;
     VkImageViewType view_type;
-    VkExtent3D extent;
 
-    extent.width = m_desc.image_width;
-    extent.height = m_desc.image_height;
-    extent.depth = m_desc.image_depth;
+    m_extent.width = m_desc.image_width;
+    m_extent.height = m_desc.image_height;
+    m_extent.depth = m_desc.image_depth;
+
+    uint32_t array_layers = 1;
+    if ((m_desc.image_type == CL_MEM_OBJECT_IMAGE1D_ARRAY) ||
+        (m_desc.image_type == CL_MEM_OBJECT_IMAGE2D_ARRAY)) {
+        array_layers = m_desc.image_array_size;
+    }
+
+    uint32_t row_pitch = m_desc.image_row_pitch;
+    if (row_pitch == 0) {
+        row_pitch = m_extent.width * element_size();
+    }
+    uint32_t slice_pitch = m_desc.image_slice_pitch;
+    if (slice_pitch == 0) {
+        slice_pitch = row_pitch * m_extent.height;
+    }
+
+    size_t host_ptr_size = 0;
 
     switch (m_desc.image_type) {
     case CL_MEM_OBJECT_IMAGE1D_BUFFER:
     case CL_MEM_OBJECT_IMAGE1D:
         image_type = VK_IMAGE_TYPE_1D;
         view_type = VK_IMAGE_VIEW_TYPE_1D;
-        extent.height = 1;
-        extent.depth = 1;
+        m_extent.height = 1;
+        m_extent.depth = 1;
+        host_ptr_size = row_pitch;
         break;
     case CL_MEM_OBJECT_IMAGE1D_ARRAY:
         image_type = VK_IMAGE_TYPE_1D;
         view_type = VK_IMAGE_VIEW_TYPE_1D_ARRAY;
-        extent.height = 1;
-        extent.depth = 1;
+        m_extent.height = 1;
+        m_extent.depth = 1;
+        host_ptr_size = row_pitch * array_layers;
         break;
     case CL_MEM_OBJECT_IMAGE2D:
         image_type = VK_IMAGE_TYPE_2D;
         view_type = VK_IMAGE_VIEW_TYPE_2D;
-        extent.depth = 1;
+        m_extent.depth = 1;
+        host_ptr_size = slice_pitch;
         break;
     case CL_MEM_OBJECT_IMAGE2D_ARRAY:
         image_type = VK_IMAGE_TYPE_2D;
         view_type = VK_IMAGE_VIEW_TYPE_2D_ARRAY;
-        extent.depth = 1;
+        m_extent.depth = 1;
+        host_ptr_size = slice_pitch * array_layers;
         break;
     case CL_MEM_OBJECT_IMAGE3D:
         image_type = VK_IMAGE_TYPE_3D;
         view_type = VK_IMAGE_VIEW_TYPE_3D;
+        host_ptr_size = slice_pitch * m_extent.depth;
         break;
     default:
         CVK_ASSERT(false);
@@ -294,12 +316,6 @@ bool cvk_image::init() {
         break;
     }
 
-    uint32_t array_layers = 1;
-    if ((m_desc.image_type == CL_MEM_OBJECT_IMAGE1D_ARRAY) ||
-        (m_desc.image_type == CL_MEM_OBJECT_IMAGE2D_ARRAY)) {
-        array_layers = m_desc.image_array_size;
-    }
-
     // Translate format
     VkFormat format;
     VkComponentMapping components;
@@ -317,7 +333,7 @@ bool cvk_image::init() {
         0,                       // flags
         image_type,              // imageType
         format,                  // format
-        extent,                  // extent
+        m_extent,                // extent
         1,                       // mipLevels
         array_layers,            // arrayLayers
         VK_SAMPLE_COUNT_1_BIT,   // samples
@@ -364,7 +380,7 @@ bool cvk_image::init() {
         }
     }
 
-    // Bind the buffer to memory
+    // Bind the image to memory
     res = vkBindImageMemory(vkdev, m_image, m_memory->vulkan_memory(), 0);
 
     if (res != VK_SUCCESS) {
@@ -394,7 +410,32 @@ bool cvk_image::init() {
     res =
         vkCreateImageView(vkdev, &imageViewCreateInfo, nullptr, &m_image_view);
 
-    return res == VK_SUCCESS;
+    if (res != VK_SUCCESS) {
+        return false;
+    }
+
+    if (has_any_flag(CL_MEM_COPY_HOST_PTR | CL_MEM_USE_HOST_PTR)) {
+        // Create a staging buffer to copy to the device later.
+        cl_int ret;
+        m_init_data = cvk_buffer::create(m_context, CL_MEM_READ_ONLY,
+                                         host_ptr_size, nullptr, &ret);
+        if (ret != CL_SUCCESS) {
+            cvk_error("Could not create staging buffer for image host_ptr");
+            return false;
+        }
+
+        if (!m_init_data->map()) {
+            cvk_error("Could not map staging buffer");
+            return false;
+        }
+
+        // Copy data to staging buffer.
+        void* dst = m_init_data->map_ptr(0);
+        memcpy(dst, m_host_ptr, host_ptr_size);
+        m_init_data->unmap();
+    }
+
+    return true;
 }
 
 void cvk_image::prepare_fill_pattern(const void* input_pattern,
@@ -533,3 +574,135 @@ void cvk_image::prepare_fill_pattern(const void* input_pattern,
         CVK_ASSERT(false);
     }
 }
+
+bool cvk_image::prepare_for_device(cvk_command_queue& queue) {
+    std::lock_guard<std::mutex> lock(m_device_init_lock);
+
+    // Check if we have already initialized image on the device.
+    if (m_device_initialized) {
+        return true;
+    }
+
+    cvk_info("Preparing image %p for use on device", this);
+
+    // Create a command buffer and begin recording commands.
+    cvk_command_buffer command_buffer(&queue);
+    if (!command_buffer.begin()) {
+        cvk_error("Could not create command buffer for image initialization");
+        return false;
+    }
+
+    bool needs_copy = m_init_data != nullptr;
+
+    // Transition image layout to GENERAL or TRANSFER_DST_OPTIMAL.
+    VkImageSubresourceRange subresourceRange = {
+        VK_IMAGE_ASPECT_COLOR_BIT, // aspectMask
+        0,                         // baseMipLevel
+        VK_REMAINING_MIP_LEVELS,   // levelCount
+        0,                         // baseArrayLayer
+        VK_REMAINING_ARRAY_LAYERS, // layerCount
+    };
+    VkImageLayout layout = needs_copy ? VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
+                                      : VK_IMAGE_LAYOUT_GENERAL;
+    VkImageMemoryBarrier imageBarrier = {
+        VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
+        nullptr,
+        0,                                                      // srcAccessMask
+        VK_ACCESS_MEMORY_READ_BIT | VK_ACCESS_MEMORY_WRITE_BIT, // dstAccessMask
+        VK_IMAGE_LAYOUT_UNDEFINED,                              // oldLayout
+        layout,                                                 // newLayout
+        0,                // srcQueueFamilyIndex
+        0,                // dstQueueFamilyIndex
+        vulkan_image(),   // image
+        subresourceRange, // subresourceRange
+    };
+    vkCmdPipelineBarrier(command_buffer, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
+                         VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
+                         0,              // dependencyFlags
+                         0,              // memoryBarrierCount
+                         nullptr,        // pMemoryBarriers
+                         0,              // bufferMemoryBarrierCount
+                         nullptr,        // pBufferMemoryBarriers
+                         1,              // imageMemoryBarrierCount
+                         &imageBarrier); // pImageMemoryBarriers
+
+    // Set up a buffer->image copy to initialize the image contents.
+    if (needs_copy) {
+        uint32_t row_length = m_desc.image_row_pitch
+                                  ? m_desc.image_row_pitch / element_size()
+                                  : m_extent.width;
+        uint32_t image_height =
+            m_desc.image_slice_pitch
+                ? m_desc.image_slice_pitch / row_length / element_size()
+                : m_extent.height;
+        uint32_t layer_count = 1;
+        if ((m_desc.image_type == CL_MEM_OBJECT_IMAGE1D_ARRAY) ||
+            (m_desc.image_type == CL_MEM_OBJECT_IMAGE2D_ARRAY)) {
+            layer_count = m_desc.image_array_size;
+        }
+        VkImageSubresourceLayers subresource = {
+            VK_IMAGE_ASPECT_COLOR_BIT, // aspectMask
+            0,                         // mipLevel
+            0,                         // baseArrayLayer
+            layer_count,               // layerCount
+        };
+        VkBufferImageCopy copy = {
+            0,            // bufferOffset
+            row_length,   // bufferRowLength
+            image_height, // bufferImageHeight
+            subresource,  // imageSubresource
+            {0, 0, 0},    // imageOffset
+            m_extent,     // imageExtent
+        };
+        vkCmdCopyBufferToImage(command_buffer, m_init_data->vulkan_buffer(),
+                               vulkan_image(),
+                               VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &copy);
+
+        // Transition image layout to GENERAL.
+        VkImageSubresourceRange subresourceRange = {
+            VK_IMAGE_ASPECT_COLOR_BIT, // aspectMask
+            0,                         // baseMipLevel
+            VK_REMAINING_MIP_LEVELS,   // levelCount
+            0,                         // baseArrayLayer
+            VK_REMAINING_ARRAY_LAYERS, // layerCount
+        };
+        VkImageMemoryBarrier imageBarrier = {
+            VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
+            nullptr,
+            VK_ACCESS_TRANSFER_WRITE_BIT,         // srcAccessMask
+            VK_ACCESS_MEMORY_READ_BIT,            // dstAccessMask
+            VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, // oldLayout
+            VK_IMAGE_LAYOUT_GENERAL,              // newLayout
+            0,                                    // srcQueueFamilyIndex
+            0,                                    // dstQueueFamilyIndex
+            vulkan_image(),                       // image
+            subresourceRange,                     // subresourceRange
+        };
+        vkCmdPipelineBarrier(command_buffer, VK_PIPELINE_STAGE_TRANSFER_BIT,
+                             VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
+                             0,              // dependencyFlags
+                             0,              // memoryBarrierCount
+                             nullptr,        // pMemoryBarriers
+                             0,              // bufferMemoryBarrierCount
+                             nullptr,        // pBufferMemoryBarriers
+                             1,              // imageMemoryBarrierCount
+                             &imageBarrier); // pImageMemoryBarriers
+    }
+
+    if (!command_buffer.end()) {
+        cvk_error("Could not end image initialization command buffer");
+        return false;
+    }
+
+    // Submit commands and wait for completion.
+    if (!command_buffer.submit_and_wait()) {
+        cvk_error("Could not execute image initialization commands");
+        return false;
+    }
+
+    m_init_data.reset();
+
+    m_device_initialized = true;
+
+    return true;
+}
diff --git a/clvk/src/memory.hpp b/clvk/src/memory.hpp
index eb54a79..8c86f55 100644
--- a/clvk/src/memory.hpp
+++ b/clvk/src/memory.hpp
@@ -20,6 +20,8 @@
 #include "objects.hpp"
 #include "utils.hpp"
 
+struct cvk_command_queue;
+
 struct cvk_memory_allocation {
 
     cvk_memory_allocation(VkDevice dev, VkDeviceSize size, uint32_t type_index)
@@ -414,7 +416,8 @@ struct cvk_image : public cvk_mem {
                   /* FIXME parent_offset */ 0, std::move(properties),
                   desc->image_type),
           m_desc(*desc), m_format(*format), m_image(VK_NULL_HANDLE),
-          m_image_view(VK_NULL_HANDLE) {}
+          m_image_view(VK_NULL_HANDLE), m_device_initialized(false),
+          m_init_data(nullptr) {}
 
     ~cvk_image() {
         auto vkdev = m_context->device()->vulkan_device();
@@ -522,6 +525,8 @@ struct cvk_image : public cvk_mem {
                               fill_pattern_array& pattern,
                               size_t* size_ret) const;
 
+    bool prepare_for_device(cvk_command_queue& queue);
+
 private:
     bool init();
 
@@ -576,9 +581,14 @@ private:
 
     const cl_image_desc m_desc;
     const cl_image_format m_format;
+    VkExtent3D m_extent;
     VkImage m_image;
     VkImageView m_image_view;
     std::unordered_map<void*, cvk_image_mapping> m_mappings;
+
+    bool m_device_initialized;
+    std::mutex m_device_init_lock;
+    std::unique_ptr<cvk_buffer> m_init_data;
 };
 
 using cvk_image_holder = refcounted_holder<cvk_image>;
diff --git a/clvk/src/queue.cpp b/clvk/src/queue.cpp
index 470d4ab..b80dec9 100644
--- a/clvk/src/queue.cpp
+++ b/clvk/src/queue.cpp
@@ -669,6 +669,20 @@ cvk_command_kernel::build_batchable_inner(cvk_command_buffer& command_buffer) {
     return CL_SUCCESS;
 }
 
+bool cvk_command_kernel::prepare_resources_for_device() {
+    for (auto& arg : m_kernel->arguments()) {
+        if (arg.kind == kernel_argument_kind::ro_image ||
+            arg.kind == kernel_argument_kind::wo_image) {
+            auto arg_value = m_argument_values->get_arg_value(arg);
+            if (!static_cast<cvk_image*>(arg_value)->prepare_for_device(
+                    *m_queue)) {
+                return false;
+            }
+        }
+    }
+    return true;
+}
+
 bool cvk_command_batchable::can_be_batched() const {
     bool unresolved_user_event_dependencies = false;
     bool unresolved_other_queue_dependencies = false;
@@ -781,6 +795,10 @@ cl_int cvk_command_batchable::get_timestamp_query_results(cl_ulong* start,
 cl_int cvk_command_batchable::do_action() {
     CVK_ASSERT(m_command_buffer);
 
+    if (!prepare_resources_for_device()) {
+        return CL_OUT_OF_RESOURCES;
+    }
+
     bool profiling = m_queue->has_property(CL_QUEUE_PROFILING_ENABLE);
     auto dev = m_queue->device();
 
@@ -835,6 +853,12 @@ cl_int cvk_command_batch::do_action() {
 
     cvk_info("executing batch of %lu commands", m_commands.size());
 
+    for (auto& cmd : m_commands) {
+        if (!cmd->prepare_resources_for_device()) {
+            return CL_OUT_OF_RESOURCES;
+        }
+    }
+
     cl_ulong sync_host, sync_dev;
     auto dev = m_queue->device();
     if (dev->has_timer_support()) {
@@ -1314,6 +1338,10 @@ void cvk_command_buffer_image_copy::build_inner_image_to_buffer(
                            1, &region);
 }
 
+bool cvk_command_buffer_image_copy::prepare_resources_for_device() {
+    return m_image->prepare_for_device(*m_queue);
+}
+
 void cvk_command_buffer_image_copy::build_inner_buffer_to_image(
     cvk_command_buffer& cmdbuf, const VkBufferImageCopy& region) {
     VkBufferMemoryBarrier bufferBarrier = {
@@ -1406,6 +1434,16 @@ cl_int cvk_command_image_image_copy::build_batchable_inner(
     return CL_SUCCESS;
 }
 
+bool cvk_command_image_image_copy::prepare_resources_for_device() {
+    if (!m_src_image->prepare_for_device(*m_queue)) {
+        return false;
+    }
+    if (!m_dst_image->prepare_for_device(*m_queue)) {
+        return false;
+    }
+    return true;
+}
+
 cl_int cvk_command_fill_image::do_action() {
     // TODO use bigger memcpy's when possible
     size_t num_elems = m_region[2] * m_region[1] * m_region[0];
diff --git a/clvk/src/queue.hpp b/clvk/src/queue.hpp
index 773e991..381876d 100644
--- a/clvk/src/queue.hpp
+++ b/clvk/src/queue.hpp
@@ -647,6 +647,8 @@ struct cvk_command_batchable : public cvk_command {
     build_batchable_inner(cvk_command_buffer& cmdbuf) = 0;
     CHECK_RETURN cl_int do_action() override;
 
+    virtual bool prepare_resources_for_device() { return true;};
+
 private:
     std::unique_ptr<cvk_command_buffer> m_command_buffer;
     VkQueryPool m_query_pool;
@@ -705,6 +707,8 @@ struct cvk_command_kernel : public cvk_command_batchable {
     CHECK_RETURN cl_int
     build_batchable_inner(cvk_command_buffer& cmdbuf) override final;
 
+    bool prepare_resources_for_device() override final;
+
 private:
     CHECK_RETURN cl_int
     build_and_dispatch_regions(cvk_command_buffer& command_buffer);
@@ -811,6 +815,8 @@ struct cvk_command_buffer_image_copy : public cvk_command_batchable {
     CHECK_RETURN cl_int
     build_batchable_inner(cvk_command_buffer& cmdbuf) override final;
 
+    bool prepare_resources_for_device() override final;
+
 private:
     void build_inner_image_to_buffer(cvk_command_buffer& cmdbuf,
                                      const VkBufferImageCopy& region);
@@ -926,6 +932,8 @@ struct cvk_command_image_image_copy : public cvk_command_batchable {
     CHECK_RETURN cl_int
     build_batchable_inner(cvk_command_buffer& cmdbuf) override final;
 
+    bool prepare_resources_for_device() override final;
+
 private:
     cvk_image_holder m_src_image;
     cvk_image_holder m_dst_image;
diff --git a/clvk/tests/api/images.cpp b/clvk/tests/api/images.cpp
index f9ef870..800a241 100644
--- a/clvk/tests/api/images.cpp
+++ b/clvk/tests/api/images.cpp
@@ -413,3 +413,126 @@ TEST_F(WithCommandQueue, ImageWriteOffset) {
 
     EXPECT_TRUE(success);
 }
+
+
+TEST_F(WithCommandQueue, ImageCopyHostPtrPadding) {
+    // Create a 2D image array.
+    const size_t IMAGE_WIDTH = 16;
+    const size_t IMAGE_HEIGHT = 16;
+    const size_t IMAGE_ARRAY_SIZE = 2;
+
+    // Pad the host pointer.
+    const size_t IMAGE_ROW_PITCH = 24;
+    const size_t IMAGE_SLICE_PITCH = IMAGE_ROW_PITCH * 32;
+
+    const cl_uchar init_value = 0xAB;
+    std::vector<cl_uchar> host_data(IMAGE_SLICE_PITCH * IMAGE_ARRAY_SIZE, 0xFF);
+    std::vector<cl_uchar> read_data(
+        IMAGE_WIDTH * IMAGE_HEIGHT * IMAGE_ARRAY_SIZE, 0);
+
+    // Fill the host pointer (skipping the padding bytes).
+    for (int a = 0; a < IMAGE_ARRAY_SIZE; a++) {
+        for (int y = 0; y < IMAGE_HEIGHT; y++) {
+            for (int x = 0; x < IMAGE_WIDTH; x++) {
+                host_data[x + y * IMAGE_ROW_PITCH + a * IMAGE_SLICE_PITCH] =
+                    init_value;
+            }
+        }
+    }
+
+    cl_image_format format = {CL_R, CL_UNSIGNED_INT8};
+    cl_image_desc desc = {
+        CL_MEM_OBJECT_IMAGE2D_ARRAY, // image_type
+        IMAGE_WIDTH,                 // image_width
+        IMAGE_HEIGHT,                // image_height
+        1,                           // image_depth
+        IMAGE_ARRAY_SIZE,            // image_array_size
+        IMAGE_ROW_PITCH,             // image_row_pitch
+        IMAGE_SLICE_PITCH,           // image_slice_pitch
+        0,                           // num_mip_levels
+        0,                           // num_samples
+        nullptr,                     // buffer
+    };
+    auto image = CreateImage(CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR, &format,
+                             &desc, host_data.data());
+
+    // Read the data back from the image.
+    size_t origin[3] = {0, 0, 0};
+    size_t region[3] = {IMAGE_WIDTH, IMAGE_HEIGHT, IMAGE_ARRAY_SIZE};
+    EnqueueReadImage(image, CL_FALSE, origin, region, 0, 0, read_data.data());
+    Finish();
+
+    // Check that we got the values copied from the initial host pointer.
+    bool success = true;
+    for (int i = 0; i < IMAGE_HEIGHT * IMAGE_WIDTH * IMAGE_ARRAY_SIZE; ++i) {
+        auto val = read_data[i];
+        if (val != init_value) {
+            printf("Failed comparison at data[%d]: expected %d but got %d\n", i,
+                   init_value, val);
+            success = false;
+        }
+    }
+    EXPECT_TRUE(success);
+}
+
+TEST_F(WithCommandQueue, ImageCopyHostPtrMultiQueue) {
+    // Create image
+    const size_t IMAGE_WIDTH = 16;
+    const size_t IMAGE_HEIGHT = 16;
+
+    const cl_uchar init_value = 0xAB;
+    const cl_uchar write_value = 0xFF;
+    std::vector<cl_uchar> host_data(IMAGE_WIDTH * IMAGE_HEIGHT, init_value);
+    std::vector<cl_uchar> write_data(IMAGE_WIDTH * IMAGE_HEIGHT, write_value);
+    std::vector<cl_uchar> read_data(IMAGE_WIDTH * IMAGE_HEIGHT, 0);
+
+    cl_image_format format = {CL_R, CL_UNSIGNED_INT8};
+    cl_image_desc desc = {
+        CL_MEM_OBJECT_IMAGE2D, // image_type
+        IMAGE_WIDTH,           // image_width
+        IMAGE_HEIGHT,          // image_height
+        1,                     // image_depth
+        1,                     // image_array_size
+        0,                     // image_row_pitch
+        0,                     // image_slice_pitch
+        0,                     // num_mip_levels
+        0,                     // num_samples
+        nullptr,               // buffer
+    };
+    auto image = CreateImage(CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR, &format,
+                             &desc, host_data.data());
+
+    size_t origin[3] = {0, 0, 0};
+    size_t region[3] = {IMAGE_WIDTH, IMAGE_HEIGHT, 1};
+
+    // Enqueue a command that writes to the image, blocked behind a user event.
+    auto user_event = CreateUserEvent();
+    cl_event wait_list = user_event;
+    EnqueueWriteImage(image, CL_FALSE, origin, region, 0, 0, write_data.data(),
+                      1, &wait_list, nullptr);
+    Flush();
+
+    // Read from the image with a different queue.
+    auto queue2 = CreateCommandQueue(device(), 0);
+    cl_int err = clEnqueueReadImage(queue2, image, CL_FALSE, origin, region, 0,
+                                    0, read_data.data(), 0, nullptr, nullptr);
+    ASSERT_CL_SUCCESS(err);
+    err = clFinish(queue2);
+    ASSERT_CL_SUCCESS(err);
+
+    // Check that we got the values copied from the initial host pointer.
+    bool success = true;
+    for (cl_uint i = 0; i < IMAGE_HEIGHT * IMAGE_WIDTH; ++i) {
+        auto val = read_data[i];
+        if (val != init_value) {
+            printf("Failed comparison at data[%d]: expected %d but got %d\n", i,
+                   init_value, val);
+            success = false;
+        }
+    }
+    EXPECT_TRUE(success);
+
+    // Unblock the first queue.
+    SetUserEventStatus(user_event, CL_COMPLETE);
+    Finish();
+}
