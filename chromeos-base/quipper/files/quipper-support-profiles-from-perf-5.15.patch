From 1019cb233dd08496574d36f1c86e4f2983253e0f Mon Sep 17 00:00:00 2001
From: denik <denik@google.com>
Date: Thu, 19 May 2022 13:11:33 -0700
Subject: [PATCH] Support profiles from perf 5.15.

- Handle "HW index" field in a branch stack sample;
- Add "size" field in build_id_event struct and PerfBuildID proto message;
- Update perf binary in testdata (new profiles are not compatible with the old perf).

Fixed the following error from the perf.data profile synthesized with perf-5.15:

  quipper/sample_info_reader.cc:747: Read/skipped 280 bytes, expected 288 bytes.
  quipper/perf_reader.cc:1023: Couldn't read event PERF_RECORD_SAMPLE

The new branch sample type was added in
https://lore.kernel.org/lkml/20200228163011.19358-3-kan.liang@linux.intel.com/.
Build id size was added in
https://lore.kernel.org/all/20201013192441.1299447-8-jolsa@kernel.org/.

PiperOrigin-RevId: 449816934
---
 src/quipper/kernel/perf_event.h               |      7 +-
 src/quipper/kernel/perf_internals.h           |     19 +-
 src/quipper/perf_data.proto                   |     15 +-
 src/quipper/perf_reader.cc                    |      9 +-
 src/quipper/perf_serializer.cc                |     14 +-
 src/quipper/perf_test_files.cc                |      9 +
 src/quipper/sample_info_reader.cc             |     61 +-
 src/quipper/sample_info_reader_test.cc        |      1 +

diff --git a/kernel/perf_event.h b/kernel/perf_event.h
index f1a8ffa..9f44a26 100644
--- a/kernel/perf_event.h
+++ b/kernel/perf_event.h
@@ -188,8 +188,9 @@ enum perf_branch_sample_type {
   PERF_SAMPLE_BRANCH_IN_TX = 1U << 8,      /* in transaction */
   PERF_SAMPLE_BRANCH_NO_TX = 1U << 9,      /* not in transaction */
   PERF_SAMPLE_BRANCH_COND = 1U << 10,      /* conditional branches */
+  PERF_SAMPLE_BRANCH_HW_INDEX = 1U << 17,  /* sample contains hw_idx field */
 
-  PERF_SAMPLE_BRANCH_MAX = 1U << 11, /* non-ABI */
+  PERF_SAMPLE_BRANCH_MAX = 1U << 18, /* non-ABI */
 };
 
 const u16 PERF_SAMPLE_BRANCH_PLM_ALL =
@@ -729,7 +730,9 @@ enum perf_event_type {
    *	  char                  data[size];}&& PERF_SAMPLE_RAW
    *
    *	{ u64                   nr;
-   *        { u64 from, to, flags } lbr[nr];} && PERF_SAMPLE_BRANCH_STACK
+   *	  { u64	hw_idx; } && PERF_SAMPLE_BRANCH_HW_INDEX
+   *      { u64 from, to, flags } lbr[nr];
+   *    } && PERF_SAMPLE_BRANCH_STACK
    *
    * 	{ u64			abi; # enum perf_sample_regs_abi
    * 	  u64			regs[weight(mask)]; } && PERF_SAMPLE_REGS_USER
diff --git a/kernel/perf_internals.h b/kernel/perf_internals.h
index fd0b6b4..3906e1f 100644
--- a/kernel/perf_internals.h
+++ b/kernel/perf_internals.h
@@ -270,6 +270,7 @@ struct branch_entry {
 
 struct branch_stack {
   u64 nr;
+  u64 hw_idx;
   struct branch_entry entries[0];
 };
 
@@ -291,6 +292,7 @@ struct perf_sample {
   u64 data_src;
   u32 flags;
   u16 insn_len;
+  bool no_hw_idx; /* No hw_idx collected in branch_stack */
   void *raw_data;
   struct ip_callchain *callchain;
   struct branch_stack *branch_stack;
@@ -334,22 +336,25 @@ struct perf_sample {
   }
 };
 
-// Taken from tools/perf/util/include/linux/kernel.h
-#define ALIGN(x, a) __ALIGN_MASK(x, (decltype(x))(a)-1)
-#define __ALIGN_MASK(x, mask) (((x) + (mask)) & ~(mask))
-
 // If this is changed, kBuildIDArraySize in perf_reader.h must also be changed.
 #define BUILD_ID_SIZE 20
 
+// The flag marks buildid events with size.
+#define PERF_RECORD_MISC_BUILD_ID_SIZE (1 << 15)
+
+// Synced with perf_record_header_build_id at
+// tools/lib/perf/include/perf/event.h.
 struct build_id_event {
   struct perf_event_header header;
   pid_t pid;
-  u8 build_id[ALIGN(BUILD_ID_SIZE, sizeof(u64))];
+  u8 build_id[BUILD_ID_SIZE];
+  u8 size;
+  // Padding for 8-byte alignment.
+  u8 reserved1__;
+  u16 reserved2__;
   char filename[];
 };
 
-#undef ALIGN
-#undef __ALIGN_MASK
 #undef BUILD_ID_SIZE
 
 enum perf_user_event_type {
diff --git a/perf_data.proto b/perf_data.proto
index 3920068..62dc34d 100644
--- a/perf_data.proto
+++ b/perf_data.proto
@@ -323,7 +323,7 @@ message PerfDataProto {
     optional uint32 cycles = 7;
   }
 
-  // Next tag: 24
+  // Next tag: 26
   message SampleEvent {
     // Instruction pointer.
     optional uint64 ip = 1;
@@ -393,6 +393,14 @@ message PerfDataProto {
 
     // Code page size
     optional uint64 code_page_size = 23;
+
+    // No hw_idx collected in branch_stack.
+    optional bool no_hw_idx = 24;
+
+    // Branch stack hw index,
+    // optional field in PERF_SAMPLE_BRANCH_STACK
+    // used when PERF_SAMPLE_BRANCH_HW_INDEX is set.
+    optional uint64 branch_stack_hw_idx = 25;
   }
 
   // ForkEvent is used for both FORK and EXIT events, which have the same data
@@ -826,7 +834,7 @@ message PerfDataProto {
     optional uint64 tracing_data_md5_prefix = 2 [deprecated = true];
   }
 
-  // Next tag: 6
+  // Next tag: 7
   message PerfBuildID {
     // Misc field in perf_event_header.
     optional uint32 misc = 1;
@@ -843,6 +851,9 @@ message PerfDataProto {
 
     // Filename Md5sum prefix.
     optional uint64 filename_md5_prefix = 5;
+
+    // Build id size.
+    optional uint32 size = 6;
   }
 
   // Next tag: 6
diff --git a/perf_reader.cc b/perf_reader.cc
index 0ecceb2..6be1c14 100644
--- a/perf_reader.cc
+++ b/perf_reader.cc
@@ -113,10 +113,11 @@ void CheckNoEventTypePadding() {
 
 void CheckNoBuildIDEventPadding() {
   build_id_event event;
-  CHECK_EQ(sizeof(event), sizeof(event.header.type) +
-                              sizeof(event.header.misc) +
-                              sizeof(event.header.size) + sizeof(event.pid) +
-                              sizeof(event.build_id));
+  CHECK_EQ(sizeof(event),
+           sizeof(event.header.type) + sizeof(event.header.misc) +
+               sizeof(event.header.size) + sizeof(event.pid) +
+               sizeof(event.build_id) + sizeof(event.size) +
+               sizeof(event.reserved1__) + sizeof(event.reserved2__));
 }
 
 // Creates a new build ID event with the given build ID string, filename, and
diff --git a/perf_serializer.cc b/perf_serializer.cc
index 94e140a..1ee5dfb 100644
--- a/perf_serializer.cc
+++ b/perf_serializer.cc
@@ -585,6 +585,8 @@ bool PerfSerializer::SerializeSampleEvent(
       sample->add_callchain(sample_info.callchain->ips[i]);
   }
   if (sample_type & PERF_SAMPLE_BRANCH_STACK) {
+    sample->set_no_hw_idx(sample_info.no_hw_idx);
+    sample->set_branch_stack_hw_idx(sample_info.branch_stack->hw_idx);
     for (size_t i = 0; i < sample_info.branch_stack->nr; ++i) {
       sample->add_branch_stack();
       const struct branch_entry& entry = sample_info.branch_stack->entries[i];
@@ -976,6 +978,8 @@ bool PerfSerializer::SerializeBuildIDEvent(
   to->set_pid(from->pid);
   to->set_filename(from->filename);
   to->set_filename_md5_prefix(Md5Prefix(from->filename));
+  if (from->header.misc & PERF_RECORD_MISC_BUILD_ID_SIZE)
+    to->set_size(from->size);
 
   // Trim out trailing zeroes from the build ID.
   string build_id = RawDataToHexString(from->build_id, kBuildIDArraySize);
@@ -1008,6 +1012,8 @@ bool PerfSerializer::DeserializeBuildIDEvent(
   event->pid = from.pid();
   memcpy(event->build_id, from.build_id_hash().c_str(),
          from.build_id_hash().size());
+  if (event->header.misc & PERF_RECORD_MISC_BUILD_ID_SIZE)
+    event->size = from.size();
 
   if (from.has_filename() && !filename.empty()) {
     CHECK_GT(
@@ -1644,9 +1650,15 @@ void PerfSerializer::GetPerfSampleInfo(const PerfDataProto_SampleEvent& sample,
   if (sample.branch_stack_size() > 0) {
     uint64_t branch_stack_size = sample.branch_stack_size();
     sample_info->branch_stack = reinterpret_cast<struct branch_stack*>(
-        new uint8_t[sizeof(uint64_t) +
+        new uint8_t[sizeof(uint64_t) + sizeof(uint64_t) +
                     branch_stack_size * sizeof(struct branch_entry)]);
     sample_info->branch_stack->nr = branch_stack_size;
+    // Older protos w/o branch_stack_hw_idx field shall have
+    // no_hw_idx set. So the perf profiles don't change.
+    sample_info->no_hw_idx = true;
+    if (sample.has_no_hw_idx()) sample_info->no_hw_idx = sample.no_hw_idx();
+    if (sample.has_branch_stack_hw_idx())
+      sample_info->branch_stack->hw_idx = sample.branch_stack_hw_idx();
     for (size_t i = 0; i < branch_stack_size; ++i) {
       struct branch_entry& entry = sample_info->branch_stack->entries[i];
       memset(&entry, 0, sizeof(entry));
diff --git a/perf_test_files.cc b/perf_test_files.cc
index df60564..d38dbda 100644
--- a/perf_test_files.cc
+++ b/perf_test_files.cc
@@ -121,12 +121,6 @@ const std::vector<const char*>& GetPerfDataFiles() {
       */
       "perf.data.intel_pt-4.14",

-      /* Obtained with:
-            "perf record -b -o /tmp/perf.data.branch-4.14 -- \
-            echo "Hello, World!"
-       */
-      "perf.data.branch-4.14",
-
       /* Perf data that contains lost sample events from perf-4.4
          Command:
             perf record -e "{cycles:pp,instructions:pp,branch-instructions:pp}"\
diff --git a/sample_info_reader.cc b/sample_info_reader.cc
index a67c8a2..73a3f71 100644
--- a/sample_info_reader.cc
+++ b/sample_info_reader.cc
@@ -13,6 +13,7 @@
 
 #include "buffer_reader.h"
 #include "buffer_writer.h"
+#include "kernel/perf_event.h"
 #include "kernel/perf_internals.h"
 #include "perf_data_utils.h"
 
@@ -165,7 +166,7 @@ bool ReadRawData(DataReader* reader, struct perf_sample* sample) {
   return true;
 }
 
-// Read branch stack info from perf data.  Corresponds to sample format type
+// Read branch stack info from perf data. Corresponds to sample format type
 // PERF_SAMPLE_BRANCH_STACK. Returns true when branch stack data is read
 // completely. Otherwise, returns false.
 bool ReadBranchStack(DataReader* reader, struct perf_sample* sample) {
@@ -173,12 +174,20 @@ bool ReadBranchStack(DataReader* reader, struct perf_sample* sample) {
   // |sample->branch_stack|.
   CHECK_EQ(static_cast<void*>(NULL), sample->branch_stack);
 
-  // The branch stack data consists of a uint64_t value |nr| followed by |nr|
-  // branch_entry structs.
+  // The branch stack data consists of a uint64_t value |nr| followed by
+  // uint64_t hw_index which is optional and |nr| branch_entry structs.
   uint64_t branch_stack_size = 0;
+  uint64_t branch_stack_hw_idx = 0;
+
   if (!reader->ReadUint64(&branch_stack_size)) {
     return false;
   }
+  // no_hw_idx is cleared when branch stack contains an extra field.
+  if (!sample->no_hw_idx) {
+    if (!reader->ReadUint64(&branch_stack_hw_idx)) {
+      return false;
+    }
+  }
 
   // Calculate the maximum possible number of branch stack entries assuming the
   // rest of the event as an array of the struct branch_entry.
@@ -191,10 +200,13 @@ bool ReadBranchStack(DataReader* reader, struct perf_sample* sample) {
     return false;
   }
 
+  // Refer to kernel/perf_internals.h for more details on the branch_stack
+  // layout.
   struct branch_stack* branch_stack = reinterpret_cast<struct branch_stack*>(
-      new uint8_t[sizeof(uint64_t) +
+      new uint8_t[sizeof(uint64_t) + sizeof(uint64_t) +
                   branch_stack_size * sizeof(struct branch_entry)]);
   branch_stack->nr = branch_stack_size;
+  branch_stack->hw_idx = branch_stack_hw_idx;
   sample->branch_stack = branch_stack;
   for (size_t i = 0; i < branch_stack_size; ++i) {
     if (!reader->ReadUint64(&branch_stack->entries[i].from) ||
@@ -372,11 +384,16 @@ bool ReadPerfSampleFromData(const event_t& event,
   }
 
   // { u64                   nr;
+  //   { u64 hw_idx; } && PERF_SAMPLE_BRANCH_HW_INDEX
   //   { u64 from, to, flags } lbr[nr];} && PERF_SAMPLE_BRANCH_STACK
-  if (sample_fields & PERF_SAMPLE_BRANCH_STACK &&
-      !ReadBranchStack(&reader, sample)) {
-    LOG(ERROR) << "Couldn't read PERF_SAMPLE_BRANCH_STACK";
-    return false;
+  if (sample_fields & PERF_SAMPLE_BRANCH_STACK) {
+    sample->no_hw_idx = false;
+    if (!(attr.branch_sample_type & PERF_SAMPLE_BRANCH_HW_INDEX))
+      sample->no_hw_idx = true;
+    if (!ReadBranchStack(&reader, sample)) {
+      LOG(ERROR) << "Couldn't read PERF_SAMPLE_BRANCH_STACK";
+      return false;
+    }
   }
 
   // { u64                   abi; # enum perf_sample_regs_abi
@@ -653,19 +670,23 @@ size_t PerfSampleDataWriter::Write(const struct perf_sample& sample,
   }
 
   // { u64                   nr;
+  //   { u64 hw_idx; } && PERF_SAMPLE_BRANCH_HW_INDEX
   //   { u64 from, to, flags } lbr[nr];} && PERF_SAMPLE_BRANCH_STACK
   if (sample_fields & PERF_SAMPLE_BRANCH_STACK) {
-    if (!sample.branch_stack) {
-      // When no branch stack is available, write the branch stack size as 0.
-      WriteData(0);
-      LOG(ERROR) << "Expecting branch stack data, but none was found.";
-    } else {
-      WriteData(sample.branch_stack->nr);
-      for (size_t i = 0; i < sample.branch_stack->nr; ++i) {
-        WriteData(sample.branch_stack->entries[i].from);
-        WriteData(sample.branch_stack->entries[i].to);
-        WriteData(sizeof(uint64_t), &sample.branch_stack->entries[i].flags);
-      }
+    uint64_t branch_stack_size = 0;
+    uint64_t branch_stack_hw_idx = 0;
+
+    if (sample.branch_stack) {
+      branch_stack_size = sample.branch_stack->nr;
+      branch_stack_hw_idx = sample.branch_stack->hw_idx;
+    }
+
+    WriteData(branch_stack_size);
+    if (!sample.no_hw_idx) WriteData(branch_stack_hw_idx);
+    for (size_t i = 0; i < branch_stack_size; ++i) {
+      WriteData(sample.branch_stack->entries[i].from);
+      WriteData(sample.branch_stack->entries[i].to);
+      WriteData(sizeof(uint64_t), &sample.branch_stack->entries[i].flags);
     }
   }
 
diff --git a/sample_info_reader_test.cc b/sample_info_reader_test.cc
index 0bfd965..a53d87b 100644
--- a/sample_info_reader_test.cc
+++ b/sample_info_reader_test.cc
@@ -433,6 +433,7 @@ TEST(SampleInfoReaderTest, WriteSampleEventWithZeroBranchStack) {
   sample.time = 1415837014 * 1000000000ULL;
   sample.cpu = 8;
   sample.period = 10001;
+  sample.no_hw_idx = true;
 
   ASSERT_TRUE(reader.WritePerfSampleInfo(sample, event));
 
-- 
2.36.1.124.g0e6072fb45-goog

