This is a cherrypick necessary to fix crbug.com/1141457

It includes modifications to vendor/, since that's easier to modify in .patch
form than uploading another tarball of these sources + manually adding
`[patch.*]` directives to Cargo.toml files.

rustc_parse: More precise spans for `tuple.0.0`
https://github.com/rust-lang/rust/commit/dee704930d8a543e1a51cb706fe2216238cdcfef

diff --git a/src/librustc_parse/parser/expr.rs b/src/librustc_parse/parser/expr.rs
index f022c628fe2..60e2f6dda64 100644
--- a/src/librustc_parse/parser/expr.rs
+++ b/src/librustc_parse/parser/expr.rs
@@ -16,6 +16,7 @@ use rustc_ast_pretty::pprust;
 use rustc_errors::{Applicability, DiagnosticBuilder, PResult};
 use rustc_span::source_map::{self, Span, Spanned};
 use rustc_span::symbol::{kw, sym, Ident, Symbol};
+use rustc_span::{BytePos, Pos};
 use std::mem;
 use tracing::debug;
 
@@ -839,9 +840,10 @@ impl<'a> Parser<'a> {
         }
         use FloatComponent::*;
 
+        let float_str = float.as_str();
         let mut components = Vec::new();
         let mut ident_like = String::new();
-        for c in float.as_str().chars() {
+        for c in float_str.chars() {
             if c == '_' || c.is_ascii_alphanumeric() {
                 ident_like.push(c);
             } else if matches!(c, '.' | '+' | '-') {
@@ -857,8 +859,13 @@ impl<'a> Parser<'a> {
             components.push(IdentLike(ident_like));
         }
 
-        // FIXME: Make the span more precise.
+        // With proc macros the span can refer to anything, the source may be too short,
+        // or too long, or non-ASCII. It only makes sense to break our span into components
+        // if its underlying text is identical to our float literal.
         let span = self.token.span;
+        let can_take_span_apart =
+            || self.span_to_snippet(span).as_deref() == Ok(float_str).as_deref();
+
         match &*components {
             // 1e2
             [IdentLike(i)] => {
@@ -866,21 +873,40 @@ impl<'a> Parser<'a> {
             }
             // 1.
             [IdentLike(i), Punct('.')] => {
+                let (ident_span, dot_span) = if can_take_span_apart() {
+                    let (span, ident_len) = (span.data(), BytePos::from_usize(i.len()));
+                    let ident_span = span.with_hi(span.lo + ident_len);
+                    let dot_span = span.with_lo(span.lo + ident_len);
+                    (ident_span, dot_span)
+                } else {
+                    (span, span)
+                };
                 assert!(suffix.is_none());
                 let symbol = Symbol::intern(&i);
-                self.token = Token::new(token::Ident(symbol, false), span);
-                let next_token = Token::new(token::Dot, span);
+                self.token = Token::new(token::Ident(symbol, false), ident_span);
+                let next_token = Token::new(token::Dot, dot_span);
                 self.parse_tuple_field_access_expr(lo, base, symbol, None, Some(next_token))
             }
             // 1.2 | 1.2e3
             [IdentLike(i1), Punct('.'), IdentLike(i2)] => {
+                let (ident1_span, dot_span, ident2_span) = if can_take_span_apart() {
+                    let (span, ident1_len) = (span.data(), BytePos::from_usize(i1.len()));
+                    let ident1_span = span.with_hi(span.lo + ident1_len);
+                    let dot_span = span
+                        .with_lo(span.lo + ident1_len)
+                        .with_hi(span.lo + ident1_len + BytePos(1));
+                    let ident2_span = self.token.span.with_lo(span.lo + ident1_len + BytePos(1));
+                    (ident1_span, dot_span, ident2_span)
+                } else {
+                    (span, span, span)
+                };
                 let symbol1 = Symbol::intern(&i1);
-                self.token = Token::new(token::Ident(symbol1, false), span);
-                let next_token1 = Token::new(token::Dot, span);
+                self.token = Token::new(token::Ident(symbol1, false), ident1_span);
+                let next_token1 = Token::new(token::Dot, dot_span);
                 let base1 =
                     self.parse_tuple_field_access_expr(lo, base, symbol1, None, Some(next_token1));
                 let symbol2 = Symbol::intern(&i2);
-                let next_token2 = Token::new(token::Ident(symbol2, false), span);
+                let next_token2 = Token::new(token::Ident(symbol2, false), ident2_span);
                 self.bump_with(next_token2); // `.`
                 self.parse_tuple_field_access_expr(lo, base1, symbol2, suffix, None)
             }
diff --git a/vendor/rustc-ap-rustc_parse/.cargo-checksum.json b/vendor/rustc-ap-rustc_parse/.cargo-checksum.json
index 21a28917759..ad503e31574 100644
--- a/vendor/rustc-ap-rustc_parse/.cargo-checksum.json
+++ b/vendor/rustc-ap-rustc_parse/.cargo-checksum.json
@@ -1 +1 @@
-{"files":{"Cargo.toml":"fdc354817fe9143d72daf9b26675221e0127d5c8882295e44f127b068988bd88","lexer/mod.rs":"502c7635fa94f95d27965351d0890d3a67f131dd68b308309e122f5ac0f104f5","lexer/tokentrees.rs":"14ae9393b3d86dc5d92e19b35344c58b0fe060affa5cd800ea8561051b85c390","lexer/unescape_error_reporting.rs":"b275aa094d31dbcd6c19f6183e41ced96edd65b2cb6125c6a3053048f8b002a6","lexer/unicode_chars.rs":"8174dd5dfe5c70128c1f946af336c66e46740570d7869e3b1460148ea03045d5","lib.rs":"5182e554747fbdf5c8cbff36880c5a4d24ad31c27a79092538a5bde7b2437b51","parser/attr.rs":"41fe4550a0a5686eb4b19bc0d80121ce9a4e50761753df1dbfbdf883d7f63af2","parser/diagnostics.rs":"b716282b88549758395ee1924b1ab18f805c554ee28dcd24df3f70877ad8d3c4","parser/expr.rs":"f0faa067c926be5b1b0116a866f5a5db029349d09c197453568ac50d3b70bd6a","parser/generics.rs":"730eca3bce6d6f7a71fd31da95b0f5014907921fb992809585daf4887d818be1","parser/item.rs":"fa91561915bd6dd4b53bf0193ed4c64cbe3719402edcf18813e5f07ddbfd5d56","parser/mod.rs":"27cca1a3aafd4cd412159e31a5ad1dbefca2a3c07edfd2f66bfe66c5e3bc64bb","parser/pat.rs":"d22976738170562cad66913ae6ea481d7081c8ac14c392c52f66c23e62d7593b","parser/path.rs":"b3d3c36330be3e7706d672faff8c47bdfb0d268588efc981970a30a8eb36cee0","parser/stmt.rs":"1ed582ba7bffdc867a16ec178e9ddbc20cf3d20b51425cf2bd6d373cad82fef7","parser/ty.rs":"1b2c617c7f132ead48042523fdd86b15957b252c60cd0d2d217e3b8cf8a2f6e4","validate_attr.rs":"f5eaf614199d8ba67abd5f67266bfe2d30f7d886c0986f1079a5fe69474823e8"},"package":"065e632101bdd57a271f38ee7a4d72b5a3d0467ec845104346c284b2c6c69960"}
\ No newline at end of file
+{"files":{"Cargo.toml":"fdc354817fe9143d72daf9b26675221e0127d5c8882295e44f127b068988bd88","lexer/mod.rs":"502c7635fa94f95d27965351d0890d3a67f131dd68b308309e122f5ac0f104f5","lexer/tokentrees.rs":"14ae9393b3d86dc5d92e19b35344c58b0fe060affa5cd800ea8561051b85c390","lexer/unescape_error_reporting.rs":"b275aa094d31dbcd6c19f6183e41ced96edd65b2cb6125c6a3053048f8b002a6","lexer/unicode_chars.rs":"8174dd5dfe5c70128c1f946af336c66e46740570d7869e3b1460148ea03045d5","lib.rs":"5182e554747fbdf5c8cbff36880c5a4d24ad31c27a79092538a5bde7b2437b51","parser/attr.rs":"41fe4550a0a5686eb4b19bc0d80121ce9a4e50761753df1dbfbdf883d7f63af2","parser/diagnostics.rs":"b716282b88549758395ee1924b1ab18f805c554ee28dcd24df3f70877ad8d3c4","parser/expr.rs":"411640b7297d52eacc05ee580910dcf820a7a3e32c9c0bc64036c26069a13c98","parser/generics.rs":"730eca3bce6d6f7a71fd31da95b0f5014907921fb992809585daf4887d818be1","parser/item.rs":"fa91561915bd6dd4b53bf0193ed4c64cbe3719402edcf18813e5f07ddbfd5d56","parser/mod.rs":"27cca1a3aafd4cd412159e31a5ad1dbefca2a3c07edfd2f66bfe66c5e3bc64bb","parser/pat.rs":"d22976738170562cad66913ae6ea481d7081c8ac14c392c52f66c23e62d7593b","parser/path.rs":"b3d3c36330be3e7706d672faff8c47bdfb0d268588efc981970a30a8eb36cee0","parser/stmt.rs":"1ed582ba7bffdc867a16ec178e9ddbc20cf3d20b51425cf2bd6d373cad82fef7","parser/ty.rs":"1b2c617c7f132ead48042523fdd86b15957b252c60cd0d2d217e3b8cf8a2f6e4","validate_attr.rs":"f5eaf614199d8ba67abd5f67266bfe2d30f7d886c0986f1079a5fe69474823e8"},"package":"065e632101bdd57a271f38ee7a4d72b5a3d0467ec845104346c284b2c6c69960"}
diff --git a/vendor/rustc-ap-rustc_parse/parser/expr.rs b/vendor/rustc-ap-rustc_parse/parser/expr.rs
index d06b172bc14..7ea6b5b0650 100644
--- a/vendor/rustc-ap-rustc_parse/parser/expr.rs
+++ b/vendor/rustc-ap-rustc_parse/parser/expr.rs
@@ -17,6 +17,7 @@ use rustc_ast_pretty::pprust;
 use rustc_errors::{Applicability, DiagnosticBuilder, PResult};
 use rustc_span::source_map::{self, Span, Spanned};
 use rustc_span::symbol::{kw, sym, Ident, Symbol};
+use rustc_span::{BytePos, Pos};
 use std::mem;
 
 /// Possibly accepts an `token::Interpolated` expression (a pre-parsed expression
@@ -809,9 +810,10 @@ impl<'a> Parser<'a> {
         }
         use FloatComponent::*;
 
+        let float_str = float.as_str();
         let mut components = Vec::new();
         let mut ident_like = String::new();
-        for c in float.as_str().chars() {
+        for c in float_str.chars() {
             if c == '_' || c.is_ascii_alphanumeric() {
                 ident_like.push(c);
             } else if matches!(c, '.' | '+' | '-') {
@@ -827,8 +829,13 @@ impl<'a> Parser<'a> {
             components.push(IdentLike(ident_like));
         }
 
-        // FIXME: Make the span more precise.
+        // With proc macros the span can refer to anything, the source may be too short,
+        // or too long, or non-ASCII. It only makes sense to break our span into components
+        // if its underlying text is identical to our float literal.
         let span = self.token.span;
+        let can_take_span_apart =
+            || self.span_to_snippet(span).as_deref() == Ok(float_str).as_deref();
+
         match &*components {
             // 1e2
             [IdentLike(i)] => {
@@ -836,21 +843,40 @@ impl<'a> Parser<'a> {
             }
             // 1.
             [IdentLike(i), Punct('.')] => {
+                let (ident_span, dot_span) = if can_take_span_apart() {
+                    let (span, ident_len) = (span.data(), BytePos::from_usize(i.len()));
+                    let ident_span = span.with_hi(span.lo + ident_len);
+                    let dot_span = span.with_lo(span.lo + ident_len);
+                    (ident_span, dot_span)
+                } else {
+                    (span, span)
+                };
                 assert!(suffix.is_none());
                 let symbol = Symbol::intern(&i);
-                self.token = Token::new(token::Ident(symbol, false), span);
-                let next_token = Token::new(token::Dot, span);
+                self.token = Token::new(token::Ident(symbol, false), ident_span);
+                let next_token = Token::new(token::Dot, dot_span);
                 self.parse_tuple_field_access_expr(lo, base, symbol, None, Some(next_token))
             }
             // 1.2 | 1.2e3
             [IdentLike(i1), Punct('.'), IdentLike(i2)] => {
+                let (ident1_span, dot_span, ident2_span) = if can_take_span_apart() {
+                    let (span, ident1_len) = (span.data(), BytePos::from_usize(i1.len()));
+                    let ident1_span = span.with_hi(span.lo + ident1_len);
+                    let dot_span = span
+                        .with_lo(span.lo + ident1_len)
+                        .with_hi(span.lo + ident1_len + BytePos(1));
+                    let ident2_span = self.token.span.with_lo(span.lo + ident1_len + BytePos(1));
+                    (ident1_span, dot_span, ident2_span)
+                } else {
+                    (span, span, span)
+                };
                 let symbol1 = Symbol::intern(&i1);
-                self.token = Token::new(token::Ident(symbol1, false), span);
-                let next_token1 = Token::new(token::Dot, span);
+                self.token = Token::new(token::Ident(symbol1, false), ident1_span);
+                let next_token1 = Token::new(token::Dot, dot_span);
                 let base1 =
                     self.parse_tuple_field_access_expr(lo, base, symbol1, None, Some(next_token1));
                 let symbol2 = Symbol::intern(&i2);
-                let next_token2 = Token::new(token::Ident(symbol2, false), span);
+                let next_token2 = Token::new(token::Ident(symbol2, false), ident2_span);
                 self.bump_with(next_token2); // `.`
                 self.parse_tuple_field_access_expr(lo, base1, symbol2, suffix, None)
             }
