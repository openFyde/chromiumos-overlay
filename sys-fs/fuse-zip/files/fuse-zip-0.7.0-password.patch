From ee65f3a7c46d8d0d542aec188d8c8451a19ce4e9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Fran=C3=A7ois=20Degros?= <fdegros@chromium.org>
Date: Sat, 11 Jul 2020 19:19:54 +1000
Subject: [PATCH] Take password by environment variable

If no password or an empty password is provided through the PASSWORD
environment variable and the ZIP contains encrypted files, then the ZIP
is not mounted.

If a non-empty password is provided, it is used to decrypt encrypted
files. The password itself is checked for validity when the ZIP is
mounted. If the password does not allow to decrypt the first encrypted
file encountered in the ZIP, then the ZIP is not mounted. Multipassword
ZIPs containing files encrypted with different passwords are thus not
supported.
---
 lib/fuseZipData.cpp | 43 +++++++++++++++++++++++++++++++++++++++----
 1 file changed, 39 insertions(+), 4 deletions(-)

diff --git a/lib/fuseZipData.cpp b/lib/fuseZipData.cpp
index 52acdff..3d3a3dd 100644
--- a/lib/fuseZipData.cpp
+++ b/lib/fuseZipData.cpp
@@ -65,30 +65,65 @@ void FuseZipData::build_tree(bool readonly) {
     }
     m_root->parent = NULL;
     files[m_root->full_name.c_str()] = m_root;
-    zip_int64_t n = zip_get_num_entries(m_zip, 0);
+
+    // Treat empty password as "no password"
+    // See https://github.com/nih-at/libzip/issues/204
+    const char *const password = getenv("PASSWORD");
+    if (password && *password && zip_set_default_password(m_zip, password) < 0)
+        throw ZipError("Cannot set default password", m_zip);
+
+    const zip_int64_t n = zip_get_num_entries(m_zip, 0);
+
     // search for absolute or parent-relative paths
     bool needPrefix = false;
     if (readonly) {
         for (zip_int64_t i = 0; i < n; ++i) {
-            const char *name = zip_get_name(m_zip, static_cast<zip_uint64_t>(i), ZIP_FL_ENC_GUESS);
+            const char * const name = zip_get_name(m_zip, static_cast<zip_uint64_t>(i), ZIP_FL_ENC_GUESS);
+            if (!name)
+                throw ZipError("Cannot get file name", m_zip);
+
             if ((name[0] == '/') || (strncmp(name, "../", 3) == 0)) {
                 needPrefix = true;
+                break;
             }
         }
     }
+
+    zip_stat_t sb;
+
     // add zip entries for all items except hardlinks
     filemap_t origNames;
+    bool checked_password = false;
     for (zip_int64_t i = 0; i < n; ++i) {
         zip_uint64_t id = static_cast<zip_uint64_t>(i);
+        if (zip_stat_index(m_zip, id, ZIP_FL_ENC_GUESS, &sb) < 0)
+            throw ZipError("Cannot read file entry", m_zip);
+
+        if ((sb.valid & ZIP_STAT_NAME) == 0)
+            continue;
+
+        const char *const name = sb.name;
+
         bool isHardlink;
-        const char *name = zip_get_name(m_zip, id, ZIP_FL_ENC_GUESS);
         mode_t mode = getEntryAttributes(id, name, isHardlink);
-        
+
         if (isHardlink)
             continue;
 
+        // Try to open the first encrypted file in order to check the password.
+        if (!checked_password && (sb.valid & ZIP_STAT_ENCRYPTION_METHOD) != 0 &&
+            sb.encryption_method != ZIP_EM_NONE) {
+            const ZipFile file(zip_fopen_index(m_zip, id, 0));
+            if (!file)
+                throw ZipError("Cannot decrypt file", m_zip);
+
+            // Password is Ok.
+            checked_password = true;
+        }
+
         attachNode(i, name, mode, readonly, needPrefix, origNames);
     }
+
     // add hardlinks
     for (zip_int64_t i = 0; i < n; ++i) {
         zip_uint64_t id = static_cast<zip_uint64_t>(i);
-- 
2.28.0.220.ged08abb693-goog

