From bac86f86663dd697c3654da76af68f06e0ca6feb Mon Sep 17 00:00:00 2001
From: Adhemerval Zanella <adhemerval.zanella@linaro.org>
Date: Tue, 15 Jun 2021 21:00:50 -0300
Subject: [PATCH] linux: Only use 64-bit syscall if required for select

For !__ASSUME_TIME64_SYSCALLS there is no need to issue a 64-bit syscall
if the provided timeout fits in a 32-bit one.  The 64-bit usage should
be rare since the timeout is a relative one.  This also avoids the need
to use supports_time64() (which breaks the usage case of live migration
like CRIU or similar).

It also fixes an issue on 32-bit select call for !__ASSUME_PSELECT
(microblase with older kernels only) where the expected timeout
is a 'struct timeval' instead of 'struct timespec'.

Checked on i686-linux-gnu on a 4.15 kernel and on a 5.11 kernel
(with and without --enable-kernel=5.1) and on x86_64-linux-gnu.

Reviewed-by: Lukasz Majewski <lukma@denx.de>
---
 include/sys/select.h             |  5 +++
 misc/tst-select.c                | 39 ++++++++++-------
 sysdeps/unix/sysv/linux/select.c | 72 ++++++++++++++++----------------
 3 files changed, 66 insertions(+), 50 deletions(-)

diff --git a/include/sys/select.h b/include/sys/select.h
index ec073deeba..a8961afbed 100644
--- a/include/sys/select.h
+++ b/include/sys/select.h
@@ -21,6 +21,11 @@ extern int __pselect32 (int __nfds, fd_set *__readfds,
 			const struct __timespec64 *__timeout,
 			const __sigset_t *__sigmask)
   attribute_hidden;
+extern int __select32 (int __nfds, fd_set *__readfds,
+		       fd_set *__writefds, fd_set *__exceptfds,
+		       const struct __timespec64 *ts64,
+		       struct __timeval64 *timeout)
+  attribute_hidden;
 
 extern int __select64 (int __nfds, fd_set *__readfds,
 		       fd_set *__writefds, fd_set *__exceptfds,
diff --git a/misc/tst-select.c b/misc/tst-select.c
index 52aa26651f..134eed99be 100644
--- a/misc/tst-select.c
+++ b/misc/tst-select.c
@@ -17,6 +17,7 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include <errno.h>
+#include <intprops.h>
 #include <support/capture_subprocess.h>
 #include <support/check.h>
 #include <support/support.h>
@@ -31,12 +32,6 @@ struct child_args
   struct timeval tmo;
 };
 
-static void
-alarm_handler (int signum)
-{
-  /* Do nothing.  */
-}
-
 static void
 do_test_child (void *clousure)
 {
@@ -69,17 +64,20 @@ do_test_child (void *clousure)
 static void
 do_test_child_alarm (void *clousure)
 {
-  struct sigaction act = { .sa_handler = alarm_handler };
-  xsigaction (SIGALRM, &act, NULL);
-  alarm (1);
+  struct child_args *args = (struct child_args *) clousure;
 
-  struct timeval tv = { .tv_sec = 10, .tv_usec = 0 };
+  support_create_timer (0, 100000000, false, NULL);
+  struct timeval tv = { .tv_sec = args->tmo.tv_sec, .tv_usec = 0 };
   int r = select (0, NULL, NULL, NULL, &tv);
   TEST_COMPARE (r, -1);
-  TEST_COMPARE (errno, EINTR);
-
-  if (support_select_modifies_timeout ())
-    TEST_VERIFY (tv.tv_sec < 10);
+  if (args->tmo.tv_sec > INT_MAX)
+    TEST_VERIFY (errno == EINTR || errno == EOVERFLOW);
+  else
+    {
+      TEST_COMPARE (errno, EINTR);
+      if (support_select_modifies_timeout ())
+       TEST_VERIFY (tv.tv_sec < args->tmo.tv_sec);
+    }
 }
 
 static int
@@ -121,13 +119,24 @@ do_test (void)
   xclose (args.fds[0][0]);
   xclose (args.fds[1][1]);
 
+  args.tmo = (struct timeval) { .tv_sec = 10, .tv_usec = 0 };
+  {
+    struct support_capture_subprocess result;
+    result = support_capture_subprocess (do_test_child_alarm, &args);
+    support_capture_subprocess_check (&result, "tst-select-child", 0,
+				      sc_allow_none);
+  }
+
+  args.tmo = (struct timeval) { .tv_sec = TYPE_MAXIMUM (time_t),
+				.tv_usec = 0 };
   {
     struct support_capture_subprocess result;
-    result = support_capture_subprocess (do_test_child_alarm, NULL);
+    result = support_capture_subprocess (do_test_child_alarm, &args);
     support_capture_subprocess_check (&result, "tst-select-child", 0,
 				      sc_allow_none);
   }
 
+  args.tmo = (struct timeval) { .tv_sec = 0, .tv_usec = 0 };
   {
     fd_set rfds;
     FD_ZERO (&rfds);
diff --git a/sysdeps/unix/sysv/linux/select.c b/sysdeps/unix/sysv/linux/select.c
index dc16a816ed..da25b4b4cf 100644
--- a/sysdeps/unix/sysv/linux/select.c
+++ b/sysdeps/unix/sysv/linux/select.c
@@ -21,7 +21,6 @@
 #include <sys/select.h>
 #include <errno.h>
 #include <sysdep-cancel.h>
-#include <time64-support.h>
 
 /* Check the first NFDS descriptors each in READFDS (if not NULL) for read
    readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS
@@ -65,53 +64,56 @@ __select64 (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
 #ifndef __NR_pselect6_time64
 # define __NR_pselect6_time64 __NR_pselect6
 #endif
-  int r;
-  if (supports_time64 ())
-    {
-      r = SYSCALL_CANCEL (pselect6_time64, nfds, readfds, writefds, exceptfds,
+
+#ifdef __ASSUME_TIME64_SYSCALLS
+  int r = SYSCALL_CANCEL (pselect6_time64, nfds, readfds, writefds, exceptfds,
 			  pts64, NULL);
-      /* Linux by default will update the timeout after a pselect6 syscall
-         (though the pselect() glibc call suppresses this behavior).
-         Since select() on Linux has the same behavior as the pselect6
-         syscall, we update the timeout here.  */
-      if (r >= 0 || errno != ENOSYS)
+  if (timeout != NULL)
+    TIMESPEC_TO_TIMEVAL (timeout, pts64);
+  return r;
+#else
+  bool need_time64 = timeout != NULL && !in_time_t_range (timeout->tv_sec);
+  if (need_time64)
+    {
+      int r = SYSCALL_CANCEL (pselect6_time64, nfds, readfds, writefds,
+			      exceptfds, pts64, NULL);
+      if ((r >= 0 || errno != ENOSYS) && timeout != NULL)
 	{
-	  if (timeout != NULL)
-	    TIMESPEC_TO_TIMEVAL (timeout, &ts64);
-	  return r;
+	  TIMESPEC_TO_TIMEVAL (timeout, &ts64);
 	}
-
-      mark_time64_unsupported ();
+      else
+	__set_errno (EOVERFLOW);
+      return r;
     }
 
-#ifndef __ASSUME_TIME64_SYSCALLS
+# ifdef __ASSUME_PSELECT
   struct timespec ts32, *pts32 = NULL;
   if (pts64 != NULL)
     {
-      if (! in_time_t_range (pts64->tv_sec))
-	{
-	  __set_errno (EINVAL);
-	  return -1;
-	}
-      ts32.tv_sec = s;
-      ts32.tv_nsec = ns;
+      ts32.tv_sec = pts64->tv_sec;
+      ts32.tv_nsec = pts64->tv_nsec;
       pts32 = &ts32;
     }
-# ifndef __ASSUME_PSELECT
-#  ifdef __NR__newselect
-#   undef __NR_select
-#   define __NR_select __NR__newselect
-#  endif
-  r = SYSCALL_CANCEL (select, nfds, readfds, writefds, exceptfds, pts32);
-# else
-  r = SYSCALL_CANCEL (pselect6, nfds, readfds, writefds, exceptfds, pts32,
-		      NULL);
-# endif
+
+  int r = SYSCALL_CANCEL (pselect6, nfds, readfds, writefds, exceptfds, pts32,
+			  NULL);
   if (timeout != NULL)
-    *timeout = valid_timespec_to_timeval64 (ts32);
-#endif
+    TIMESPEC_TO_TIMEVAL (timeout, pts32);
+  return r;
+# else
+  struct timeval tv32, *ptv32 = NULL;
+  if (pts64 != NULL)
+    {
+      tv32 = valid_timespec64_to_timeval (*pts64);
+      ptv32 = &tv32;
+    }
 
+  int r = SYSCALL_CANCEL (select, nfds, readfds, writefds, exceptfds, ptv32);
+  if (timeout != NULL)
+    *timeout = valid_timeval_to_timeval64 (tv32);
   return r;
+# endif /* __ASSUME_PSELECT  */
+#endif
 }
 
 #if __TIMESIZE != 64
-- 
2.33.1

